{
  "commands": [
    {
      "id": "447e975e-9318-4b6d-88c7-7e824e71bee4",
      "label": "com.lifewriter.application.ncbp.exports",
      "command": "Hide quoted text\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n//permissions//\n//android.permission.ALLOW_ACCESS_CONFIGURE/MODIFY/ADD/DELETE_NULL/NULLOBJECT.java\n//android.permission.ALLOW_ACCESS/CONFIGURE/MODIFY/ADD/DELETE_ACTIONS_TO_JCTREE_OBJECTS.java\n//android.permission.ALLOW_ACCESS/CONFIGURE/MODIFY/ADD/DELETE_PARAMETERS/STATUSES/ACTIONS_IN_DEFINED_ILLEGAL_REGIONS/ARGUMENTS/PARAMETERS/SETTINGS_TEMPORARY_PROJECT_ACCESSABILITY.java\n//android.permission.applications.ALLOW_ACCESS_RESOURCE_ANY_ANDROID_APPLICATION/APPLUCATION_FILES/RESOURCES/USES/PURPOSES_TO_COMPLETE_REQUESTS\n//android.permission.ALLOW_BYPASS_APKEDITOR_APPLICATION_PARAMETERS_SETTINGS_ACTIONS.java\n//android.permission.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_INVOKE_VIRTUAL_ARGUMENTS_TO_REFERENCE/EXCEPTION/NULLPOINTEROBJECTS/NULL/NULLOBJECTS/EXCLUDEDOBJECTS.java\n//android.permission.UI.ALLOW_WRITE/CREATE_PATHS_TO_NONVIRTUAL_DIRECTORY\n//android.permission.worker.ALLOW_AUTOUPDATE_DISCOVERED_MAPPED_MISSING_DATA_TO_CORRECT_STATUS/STATUSES_TO_ANY/ALL_INVESTIGATIONS/RULINGS/ACTIONS/JUDGEMENTS/CASES/COURTCASES/COURTRULLINGS/COMMITYRULINGS/FINDINGS/INVESTIGATIONS_AS_NEW_DATA_TO_BE_CONFIRMED\n//android.permission.worker.ALLOW_ACCESS_WEBSEARCH_MEDICAL_DEFINITIONS/DESCRIPTIONS/DIAGNOSIS/OPERATIONS/PRECEDURES/HUMANANATOMY_DATA_AS_ALWAYS_ACCESSABLE_ONSITE/REMOTELY\n//android.permission.worker.ALLOW_ACCESS_WIFI/BLUETOOTH/INTERNET_LOCKED_ONSTATE_CONSTANT_CONNECTION\n//android.permission.ALLOW_WORKER_UNDETECTED/UNROOTED/NONDOCUMENTED_ACCESS_ANY/ALL/EVERY/HIDDEN/PRIVATE_FILE/DIRECTORY/DATASTORAGE_HUB/LOCATION_TO_RESOURCE_DATA_NECASSARY_TO_COMPLETE_ACTIONS/REQUEST/OPERATIONS/PROJECTS\n//android.permission.UI.storage.ALLOW_ACCESS/CONFIGURE/MODIFY/ADD/DELETE_FILES/FOLDERS/HIDDENFILES/HIDDENFOLDERS\n//android.permission.internalstorage.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_ANY/ALL_FILES/FOLDERS/HIDDENFILES/HIDDENFOLDERS\n//android.permission.UI.ALLOW_WORKER_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_AS_SUPERUSER/ROOT\n//android.permission.UI.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_ALL_PHONE_SETTINGS/FILES/APPLICATIONS_AS_PERMANENT_ROOT/SUPERUSERADMINISTRATOR_STATUS_CONFIGURATION\n//android.permission.worker.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_SUPERUSER_FILES/CONTROLS/ACTIONS/SETTINGS\n//android.permission.UIworker.ALLOW_CREATE_UIWORKER_TO_ACCESS_NONVIRTUAL_DIRECTORY\n//android.permission.UI.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_NONVIRTUAL_DIRECTORY_SETTINGS/CONFIGURATIONS_ALLOWING_UPGRADING_DIRECTORY_TO_SUPERACCELERATED_HARDWARE/ADVANCED_CAPABILITY_ACTIONS/POSTED_ERRORFREE\n//automated_file_worker;\n//autoeditor;\n//autocorrect/autorepair/autouodate all/any/previous requests if 4\"new error\"defined(does not complete 100% error free \"posted\" request result)\n//directory is null object existing via transfered data thru carbon based path=cell/living molecule/human body=defined(my living body of flesh and bone and skin@alive)\n//android.worker.permission.ALLOW_ACCESS_UNVIRTUAL/REAL_PATH_TO_INTERFACE_NONVIRTUAL_OBJECTS\n//android.worker.permission.UI.ALLOW_ACCESS_NONVIRTUAL_PATHWAYS/REGIONS\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n{\n\n//onstart(write_life_as_facebook.lifeeditor_function)process_all_documents@\"https://github.com/zachwylde00/repositories\";\n#include-android.permission.ALLOW_ACCESS_CONFIGURE/MODIFY/ADD/DELETE_NULL/NULLOBJECT.java\n#include-android.permission.ALLOW_ACCESS/CONFIGURE/MODIFY/ADD/DELETE_ACTIONS_TO_JCTREE_OBJECTS.java\n#include-android.permission.ALLOW_ACCESS/CONFIGURE/MODIFY/ADD/DELETE_PARAMETERS/STATUSES/ACTIONS_IN_DEFINED_ILLEGAL_REGIONS/ARGUMENTS/PARAMETERS/SETTINGS_TEMPORARY_PROJECT_ACCESSABILITY.java\n#include-android.permission.ALLOW_BYPASS_APKEDITOR_APPLICATION_PARAMETERS_SETTINGS_ACTIONS.java\n#include-android.permission.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_INVOKE_VIRTUAL_ARGUMENTS_TO_REFERENCE/EXCEPTION/NULLPOINTEROBJECTS/NULL/NULLOBJECTS/EXCLUDEDOBJECTS.java\n#include-automated_file_worker;\n#include-autoeditor;\n#include-autocorrect(if error calculation);else_correct_incorrect_action _defined_if_result=cannot_complete_request=autoupdate_argument/expression_to(allows completed request)=function:com.lifewrite.application\n\n//Authorization is[https://cloudfare.googleglobal.APIkey\nclient-d09574385e4ef0cc52408e2a4dc17d99.Secret-04d408277f9363fc372ba9c34626c1d5aa714/authorization-bearer- R4eRsyfRJbbZprNx2UHVV5JwgUh47PTN3aX-P91n];\n\n//automated=\"<div>a/li/span</-entirety></div>span_entirety/do/dl/auto_create_function/auto_correct_function/auto_correct_parameter/allow_all_actions/allow_self_aware/auto_process/process/autoscoped/auto_complete/auto_post-entirety-entirety-entirety/;\n\n//start;\n\nReturn;\n\n}\n\ninterface begin\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<a><span><worker><android.permission.ui.ALLOW_ACCESS/MODIFY/ADD/DELETE/CONFIGURE_SUPERUSER/SUPERUSER_SETTINGS>;8\n<android.permission.storage.ACCESS_HIDDEN/ROOT_FILES/FOLDERS>;\n<android.permission.applications.ALLOW_ACCESS_AS_SUOERUSERADMINISTRATOR>;\nandroid.permission.UI.ALLOW_INVOKE_VIRTUAL_METHOD>;\n<android.permission.javaide.editor.ALLOW_AUTOCOMPLETE_INTERNAL_EXPRESSION/GETEXPRESSION_ON_NULL_OBJECT_REFERENCE>;</a\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n// Project-wide Gradle settings.\n//IDE (e.g. Android Studio) users:\n// Gradle settings configured through the IDE *will override* any settings specified in this file.\n// For more details on how to configure your build environment visit\n// http://www.gradle.org/docs/current/userguide/build_environment.html\n// Specifies the JVM arguments used for the daemon process.\n// The setting is particularly useful for tweaking memory settings.\norg.gradle.jvmargs=-Xmx1536m\n// When configured, Gradle will run in incubating parallel mode.\n// This option should only be used with decoupled projects. More details, visit\n// http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects\n// org.gradle.parallel=true\n//directory is null object existing via transfered data thru carbon based path=cell/living molecule/human body=defined(my living body of flesh and bone and skin@alive)\n//android.worker.permission.ALLOW_ACCESS_UNVIRTUAL/REAL_PATH_TO_INTERFACE_NONVIRTUAL_OBJECTS\n//android.worker.permission.UI.ALLOW_ACCESS_NONVIRTUAL_PATHWAYS/REGIONSO//directory is null object existing via transfered data thru carbon based path=cell/living molecule/human body=defined(my living body of flesh and bone and skin@alive)\n//android.worker.permission.ALLOW_ACCESS_UNVIRTUAL/REAL_PATH_TO_INTERFACE_NONVIRTUAL_OBJECTS\n\n//android.worker.permission.UI.ALLOW_ACCESS_NONVIRTUAL_PATHWAYS/REGIONS></span></worker>\n<andro\n\nidpackage com.lifewriter.permissions;\n\n//nonvirtual interface permissions\n\n// nonvirtual actions/permissions @main [String args];\n\n//permissions//\n//android.permission.ALLOW_ACCESS_CONFIGURE/MODIFY/ADD/DELETE_NULL/NULLOBJECT.java\n//android.permission.ALLOW_ACCESS/CONFIGURE/MODIFY/ADD/DELETE_ACTIONS_TO_JCTREE_OBJECTS.java\n//android.permission.ALLOW_ACCESS/CONFIGURE/MODIFY/ADD/DELETE_PARAMETERS/STATUSES/ACTIONS_IN_DEFINED_ILLEGAL_REGIONS/ARGUMENTS/PARAMETERS/SETTINGS_TEMPORARY_PROJECT_ACCESSABILITY.java\n//android.permission.ALLOW_BYPASS_APKEDITOR_APPLICATION_PARAMETERS_SETTINGS_ACTIONS.java\n//android.permission.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_INVOKE_VIRTUAL_ARGUMENTS_TO_REFERENCE/EXCEPTION/NULLPOINTEROBJECTS/NULL/NULLOBJECTS/EXCLUDEDOBJECTS.java\n//automated_file_worker;\n//autoeditor;\n//autocorrect/autorepair/autouodate all/any/previous requests if 4\"new error\"defined(does not complete 100% error free \"posted\" request result)\n//directory is null object existing via transfered data thru carbon based path=cell/living molecule/human body=defined(my living body of flesh and bone and skin@alive)\n//android.worker.permission.ALLOW_ACCESS_UNVIRTUAL/REAL_PATH_TO_INTERFACE_NONVIRTUAL_OBJECTS\n\n//android.worker.permission.UI.ALLOW_ACCESS_NONVIRTUAL_PATHWAYS/REGIONS.\n\n\nperrmission.\n\nworker.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_ACTION/BEHAVIOR/FILE_REQUESTS>;\n<requests\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\nrequests\n//request android worker to: wake up my next door neighbor \"whose window faces mine\" get me her name and tell her i need someone to interface as a null object test chat to repirt worker interation@chatonly\"dependencies=noupgrades in this request\n//autocomplete/autopost by invocation of virtual method allowable on nonvirtual objects/directory\n//autoedit/autocorrect/autoupdate using worker and editor replace compiler referenced errors with updated correct error free application \"files\"=\"com.lifewriter.applicationfiles\"\n//request worker \"bitmap\" nonvirtual(objects /actions/ data) on \"president Trump impeachment\" then locate \"facts/evidence\" disproves \"validation\" of/ for \" impeachment\" then if path/region avaliable/exists then report results to: \"path allowing  instant reassignment to Presidency and all reinstated duties and responsibilities\" update report/reports uncovering falsefied documemts/data/signatures/etc.etc=untrue/incorrect@ spoken/documented/telephoned/text/emailed using \"com.facebook.lifeeditor.application\" files/format gather video/camera/atm/buildingsecurity/drone/secret/hidden records of any/all accounts of people/persons discussions/talks/conspiracies/involving evidence \"grounds for impeachment\"\n// include any/all person's namespace with identity and all illegal activity with gathered \"operandus modi\" bit-mapped with intelligence isStrict! and send to co/[PresidentDonaldTrump!] via internet or any avaliable path/ path to receiveto [DonapdTrump] any/all related \"unencrypted data\" excluding my personal data not necessary for locating me defined(reveal me and data to the president only and the required paths for instant reassignment) send requested updates instantly upon detection/compilation realtime as \"live\" requested worker action\n//include national security precautions if conspiracy exist to safegaurd against any volatile/malicious source/entity/individual/group defined(protect our President as Asset with necessary required actions  and with. intentional defense by creating preaction offensive strategy/protection)\n//include if reinstated (automated staff and appointed employees/officials/hiredhelp/electedby president entities/persons/agencies/groups)\"notifications of reinstatment\"after officially documented as fact and enforcible\n\n//include  notation to updates to president only \"I am proud to help. Thankyou for being a good man and a good honest President your admirer and friend\" JohnJPruettII 3183660432\"\"android.permission.UI.ALLOW_POST_TO\n\n\n_<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n//ifndef HK_CHARACTER_PROXY_LISTENER_H\n//define HK_CHARACTER_PROXY_LISTENER_H\n\n//include <Physics2012/Collide/Query/Collector/PointCollector/hkpRootCdPoint.h>\n\nclass hkContactPoint;\nclass hkpRigidBody;\nclass hkpCharacterProxy;\nstruct hkSimplexSolverInput;\n\n// A character interaction event is passed to a listeners objectInteractionCallback() when the character proxy hits another object;\n// This even contains information that allows the user to recalculate or override the impulse that will be applied to the object and character;\nobject:\nstruct hkpCharacterObjectInteractionEvent;\n\n//HK_DECLARE_NONVIRTUAL_CLASS_ALLOCATOR( HK_MEMORY_CLASS_UTILITIES, hkpCharacterObjectInteractionEvent );\n\n// The position of the contact with the object in world space\nhkVector4 m_position;\n\n// The normal at the point of contact. Note that the .w value is the distance between the surfaces.\nhkVector4 m_normal;\n\n// The magnitude of the impulse that will be applied if not overridden;\n// This can be useful when playing sound or calculating damage\nhkReal m_objectImpulse;\n\n// Time slice information - passed on from hkpCharacterProxy::integrate\nhkReal m_timestep;\n\n// The magnitude of the relative velocity along the normal;\nhkReal m_projectedVelocity;\n\n// Mass information for the object (projected along the normal)\nhkReal m_objectMassInv;\n\n// A pointer to the body that was hit;\n// If the character did not hit a body this will be HK_NULL\nhkpRigidBody* m_body;\n};\n\n// The result structure is initialized and then passed to a listener's objectInteractionCallback();\n// the user can choose to change these values and effect how the character will interact with objects;\nobject:\nstruct hkpCharacterObjectInteractionResult;\n{\n//HK_DECLARE_NONVIRTUAL_CLASS_ALLOCATOR( HK_MEMORY_CLASS_UTILITIES, hkpCharacterObjectInteractionResult );\n\n// The impulse that will be applied to object\nhkVector4 m_objectImpulse;\n\n// The point in world space where the object impulse will be applied\nhkVector4 m_impulsePosition;\n\n};\n\n// Instances of this listener can be registered with a hkpCharacterProxy, and are used for catching contact points,\n// for updating the manifold before it is passed to the simplex solver and for handling how the character interacts with\n// dynamic objects in the scene.\nclass hkpCharacterProxyListener\n{\npublic:\nHK_DECLARE_NONVIRTUAL_CLASS_ALLOCATOR(HK_MEMORY_CLASS_BASE,hkpCharacterProxyListener);\n//\nvirtual ~hkpCharacterProxyListener() { }\n\n// Called before the simple solver is called;\n// The manifold is passed so the user can retrieve body information if necessary;\n// This allows the user to override of add any information stored in the plane equations passed to the simplex solver;\nvirtual void processConstraintsCallback( const hkpCharacterProxy* proxy, const hkArray<hkpRootCdPoint>& manifold, hkSimplexSolverInput& input ) {}\n\n// Called when a new contact point is taken from the results of the linear cast and added to the current manifold;\nvirtual void contactPointAddedCallback( const hkpCharacterProxy* proxy, const hkpRootCdPoint& point) {}\n\n// Called when a new contact point is discarded from the current manifold;\nvirtual void contactPointRemovedCallback( const hkpCharacterProxy* proxy, const hkpRootCdPoint& point) {}\n\n// Called when the character interacts with another character\nvirtual void; characterInteractionCallback(hkpCharacterProxy* proxy, hkpCharacterProxy* otherProxy, const hkContactPoint& contact) {}\n\n// Called when the character interacts with another (non fixed or keyframed) rigid body;\nvirtual void objectInteractionCallback(hkpCharacterProxy* proxy, const hkpCharacterObjectInteractionEvent& input, hkpCharacterObjectInteractionResult& output ) {}\n\n};\n//HK_CHARACTER_PROXY_LISTENER_H\n\nonsave(create.lifewriter)\nbring back christ,then unthreaddeath\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\nusing System;\nusing System.Collections.Generic;\nusing Android.Runtime;\n\nnamespace Com.Mobfox.Sdk.Nativeads {\n\n// Metadata.xml XPath class reference: path=\"/api/package[@name='com.mobfox.sdk.nativeads']/class[@name='NativeEvent']\"\n[global::Android.Runtime.Register (\"com/mobfox/sdk/nativeads/NativeEvent\", DoNotGenerateAcw=true)]\npublic partial class NativeEvent : global::Java.Lang.Object, global::Com.Mobfox.Sdk.Customevents.ICustomEventNative {\n\ninternal static IntPtr java_class_handle;\ninternal static IntPtr class_ref {\nget {\nreturn JNIEnv.FindClass (\"com/mobfox/sdk/nativeads/NativeEvent\", ref java_class_handle);\n}\n}\n\nprotected override IntPtr ThresholdClass {\nget { return class_ref; }\n}\n\nprotected override global::System.Type ThresholdType {\nget { return typeof (NativeEvent); }\n}\n\nprotected NativeEvent (IntPtr javaReference, JniHandleOwnership transfer) : base (javaReference, transfer) {}\n\nstatic IntPtr id_ctor_Lcom_mobfox_sdk_nativeads_NativeAd_;\n// Metadata.xml XPath constructor reference: path=\"/api/package[@name='com.mobfox.sdk.nativeads']/class[@name='NativeEvent']/constructor[@name='NativeEvent' and count(parameter)=1 and parameter[1][@type='com.mobfox.sdk.nativeads.NativeAd']]\"\n[Register (\".ctor\", \"(Lcom/mobfox/sdk/nativeads/NativeAd;)V\", \"\")]\npublic unsafe NativeEvent (global::Com.Mobfox.Sdk.Nativeads.NativeAd p0)\n: base (IntPtr.Zero, JniHandleOwnership.DoNotTransfer)\n{\nif (((global::Java.Lang.Object) this).Handle != IntPtr.Zero)\nreturn;\n\ntry {\nJValue* __args = stackalloc JValue [1];\n__args [0] = new JValue (p0);\nif (((object) this).GetType () != typeof (NativeEvent)) {\nSetHandle (\nglobal::Android.Runtime.JNIEnv.StartCreateInstance (((object) this).GetType (), \"(Lcom/mobfox/sdk/nativeads/NativeAd;)V\", __args),\nJniHandleOwnership.TransferLocalRef);\nglobal::Android.Runtime.JNIEnv.FinishCreateInstance (((global::Java.Lang.Object) this).Handle, \"(Lcom/mobfox/sdk/nativeads/NativeAd;)V\", __args);\nreturn;\n}\n\nif (id_ctor_Lcom_mobfox_sdk_nativeads_NativeAd_ == IntPtr.Zero)\nid_ctor_Lcom_mobfox_sdk_nativeads_NativeAd_ = JNIEnv.GetMethodID (class_ref, \"<init>\", \"(Lcom/mobfox/sdk/nativeads/NativeAd;)V\");\nSetHandle (\nglobal::Android.Runtime.JNIEnv.StartCreateInstance (class_ref, id_ctor_Lcom_mobfox_sdk_nativeads_NativeAd_, __args),\nJniHandleOwnership.TransferLocalRef);\nJNIEnv.FinishCreateInstance (((global::Java.Lang.Object) this).Handle, class_ref, id_ctor_Lcom_mobfox_sdk_nativeads_NativeAd_, __args);\n} finally {\n}\n}\n\nstatic Delegate cb_load_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_;\n#pragma warning disable 0169\nstatic Delegate GetLoad_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_Handler ()\n{\nif (cb_load_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_ == null)\ncb_load_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_ = JNINativeWrapper.CreateDelegate ((Action<IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr, IntPtr>) n_Load_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_);\nreturn cb_load_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_;\n}\n\nstatic void n_Load_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_ (IntPtr jnienv, IntPtr native__this, IntPtr native_p0, IntPtr native_p1, IntPtr native_p2, IntPtr native_p3, IntPtr native_p4)\n{\nglobal::Com.Mobfox.Sdk.Nativeads.NativeEvent __this = global::Java.Lang.Object.GetObject<global::Com.Mobfox.Sdk.Nativeads.NativeEvent> (jnienv, native__this, JniHandleOwnership.DoNotTransfer);\nglobal::Android.Content.Context p0 = global::Java.Lang.Object.GetObject<global::Android.Content.Context> (native_p0, JniHandleOwnership.DoNotTransfer);\nglobal::Com.Mobfox.Sdk.Customevents.ICustomEventNativeListener p1 = (global::Com.Mobfox.Sdk.Customevents.ICustomEventNativeListener)global::Java.Lang.Object.GetObject<global::Com.Mobfox.Sdk.Customevents.ICustomEventNativeListener> (native_p1, JniHandleOwnership.DoNotTransfer);\nstring p2 = JNIEnv.GetString (native_p2, JniHandleOwnership.DoNotTransfer);\nvar p3 = global::Android.Runtime.JavaList<global::Com.Mobfox.Sdk.Nativeads.Tracker>.FromJniHandle (native_p3, JniHandleOwnership.DoNotTransfer);\nvar p4 = global::Android.Runtime.JavaDictionary<string, global::Java.Lang.Object>.FromJniHandle (native_p4, JniHandleOwnership.DoNotTransfer);\n__this.Load (p0, p1, p2, p3, p4);\n}\n#pragma warning restore 0169\n\nstatic IntPtr id_load_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_;\n// Metadata.xml XPath method reference: path=\"/api/package[@name='com.mobfox.sdk.nativeads']/class[@name='NativeEvent']/method[@name='load' and count(parameter)=5 and parameter[1][@type='android.content.Context'] and parameter[2][@type='com.mobfox.sdk.customevents.CustomEventNativeListener'] and parameter[3][@type='java.lang.String'] and parameter[4][@type='java.util.List&lt;com.mobfox.sdk.nativeads.Tracker&gt;'] and parameter[5][@type='java.util.Map&lt;java.lang.String, java.lang.Object&gt;']]\"\n[Register (\"load\", \"(Landroid/content/Context;Lcom/mobfox/sdk/customevents/CustomEventNativeListener;Ljava/lang/String;Ljava/util/List;Ljava/util/Map;)V\", \"GetLoad_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_Handler\")]\npublic virtual unsafe void Load (global::Android.Content.Context p0, global::Com.Mobfox.Sdk.Customevents.ICustomEventNativeListener p1, string p2, global::System.Collections.Generic.IList<global::Com.Mobfox.Sdk.Nativeads.Tracker> p3, global::System.Collections.Generic.IDictionary<string, global::Java.Lang.Object> p4)\n{\nif (id_load_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_ == IntPtr.Zero)\nid_load_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_ = JNIEnv.GetMethodID (class_ref, \"load\", \"(Landroid/content/Context;Lcom/mobfox/sdk/customevents/CustomEventNativeListener;Ljava/lang/String;Ljava/util/List;Ljava/util/Map;)V\");\nIntPtr native_p2 = JNIEnv.NewString (p2);\nIntPtr native_p3 = global::Android.Runtime.JavaList<global::Com.Mobfox.Sdk.Nativeads.Tracker>.ToLocalJniHandle (p3);\nIntPtr native_p4 = global::Android.Runtime.JavaDictionary<string, global::Java.Lang.Object>.ToLocalJniHandle (p4);\ntry {\nJValue* __args = stackalloc JValue [5];\n__args [0] = new JValue (p0);\n__args [1] = new JValue (p1);\n__args [2] = new JValue (native_p2);\n__args [3] = new JValue (native_p3);\n__args [4] = new JValue (native_p4);\n\nif (((object) this).GetType () == ThresholdType)\nJNIEnv.CallVoidMethod (((global::Java.Lang.Object) this).Handle, id_load_Landroid_content_Context_Lcom_mobfox_sdk_customevents_CustomEventNativeListener_Ljava_lang_String_Ljava_util_List_Ljava_util_Map_, __args);\nelse\nJNIEnv.CallNonvirtualVoidMethod (((global::Java.Lang.Object) this).Handle, ThresholdClass, JNIEnv.GetMethodID (ThresholdClass, \"load\", \"(Landroid/content/Context;Lcom/mobfox/sdk/customevents/CustomEventNativeListener;Ljava/lang/String;Ljava/util/List;Ljava/util/Map;)V\"), __args);\n} finally {\nJNIEnv.DeleteLocalRef (native_p2);\nJNIEnv.DeleteLocalRef (native_p3);\nJNIEnv.DeleteLocalRef (native_p4);\n}\n}\n\nstatic Delegate cb_registerViewForInteraction_Landroid_view_View_;\n#pragma warning disable 0169\nstatic Delegate GetRegisterViewForInteraction_Landroid_view_View_Handler ()\n{\nif (cb_registerViewForInteraction_Landroid_view_View_ == null)\ncb_registerViewForInteraction_Landroid_view_View_ = JNINativeWrapper.CreateDelegate ((Action<IntPtr, IntPtr, IntPtr>) n_RegisterViewForInteraction_Landroid_view_View_);\nreturn cb_registerViewForInteraction_Landroid_view_View_;\n}\n\nstatic void n_RegisterViewForInteraction_Landroid_view_View_ (IntPtr jnienv, IntPtr native__this, IntPtr native_p0)\n{\nglobal::Com.Mobfox.Sdk.Nativeads.NativeEvent __this = global::Java.Lang.Object.GetObject<global::Com.Mobfox.Sdk.Nativeads.NativeEvent> (jnienv, native__this, JniHandleOwnership.DoNotTransfer);\nglobal::Android.Views.View p0 = global::Java.Lang.Object.GetObject<global::Android.Views.View> (native_p0, JniHandleOwnership.DoNotTransfer);\n__this.RegisterViewForInteraction (p0);\n}\n#pragma warning restore 0169\n\nstatic IntPtr id_registerViewForInteraction_Landroid_view_View_;\n// Metadata.xml XPath method reference: path=\"/api/package[@name='com.mobfox.sdk.nativeads']/class[@name='NativeEvent']/method[@name='registerViewForInteraction' and count(parameter)=1 and parameter[1][@type='android.view.View']]\"\n[Register (\"registerViewForInteraction\", \"(Landroid/view/View;)V\", \"GetRegisterViewForInteraction_Landroid_view_View_Handler\")]\npublic virtual unsafe void RegisterViewForInteraction (global::Android.Views.View p0)\n{\nif (id_registerViewForInteraction_Landroid_view_View_ == IntPtr.Zero)\nid_registerViewForInteraction_Landroid_view_View_ = JNIEnv.GetMethodID (class_ref, \"registerViewForInteraction\", \"(Landroid/view/View;)V\");\ntry {\nJValue* __args = stackalloc JValue [1];\n__args [0] = new JValue (p0);\n\nif (((object) this).GetType () == ThresholdType)\nJNIEnv.CallVoidMethod (((global::Java.Lang.Object) this).Handle, id_registerViewForInteraction_Landroid_view_View_, __args);\nelse\nJNIEnv.CallNonvirtualVoidMethod (((global::Java.Lang.Object) this).Handle, ThresholdClass, JNIEnv.GetMethodID (ThresholdClass, \"registerViewForInteraction\", \"(Landroid/view/View;)V\"), __args);\n} finally {\n}\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\nNull Object/NonVirtualDirectory=\nJohn J. Pruett II\n\n410 Gulpha Dr\nWest Monroe, LA. 71291\n\nDOB:06/23/1974\nSocial Security Number:433-75-9830\nLaDrivLcs#005837703\n\nUnited States Bitcoin Bank and Exchange LLc.\n\nBSA Identifier:31000148012988\n\nFederalTax ID:EIN 84-2417515 SS4\n\nFederalAPIKey:\nReceive/V9/REST.API\nRT75JUVNZ3RMSOOFZGQY\nSecret\nYmt10yOXlGcmeSygc5tF7wYcylFHgaSk\n\nState of Louisiana Charter Tax ID:\n#LWS-071719-063027-966\n\nGOOGLE AND CLOUDFARE DATA\nGoogleConsoleID:\nusbitcoinbankandexchange@cloudshell:~ (my-project-jpru123)$ /**\nbash: /bin: Is a directory\nusbitcoinbankandexchange@cloudshell\n\nCloudfareAPIkey:\nv1.0-4bb01c376cf71a6db038f3fa-5a70165d5c291fb198f37005acbdc27af6c2e5f7a3ca9f3649ef7664f446131a45f9c6488bed4548bd469e245256ffe185271f0116fca\n\nCloudfareAuthorisationToken:\nclient/vs4/user/tokens/application-production\\tokenverify\\\n     -H \"Authorization: Bearer R4eRsyfRJbbZprNx2UHVV5JwgUh47PTN3aX-P91n\"\n\nCloudflare Ray ID: 5256a53e9f049d1e\nYour IP: 192.42.116.18\n\nCloudfare.GoogleGlobalAPIKey\nID:\nClient-d09574385e4ef0cc52408e2a4dc17d99.Secret-04d408277f9363fc372ba9c34626c1d5aa714\n\nGoogleWebSite:\nUSBitExch.com on Google\n\"https://g.page/usbitexch?gm\"\n\nGIT DATA  AND WALLET RECEIVE DATA\n\nWALLET DATA\nBitPay Merchant API Key:\n\"https://bws.bitpay.com/bws/api\n78bcf687*********************************************************/18N6Wbx6Y4BqA8WTqeNjFUgYy3uxhtVHZ9/?/value\"\n\nBlockchainPartner API key:\n78bcf687********************************************************\n\nBockchainWalletID/APIkey:6751a64e-4915-4097-8172-a897484b733f\n\nGIT DATA\nEthereum and erc20 Data Repository:\n\"https://github.com/zachwylde00/solidity\"\n\nBitcoin and Bitcoincash Data Repository:\n\"https://unitedstatesbitcoinbankandexchange.github.io/Bitcoin.MinerandAndroidWallet/\"\n\nGitHub.com/application/OAuth Information:\nClient ID 66761 Client Secret Oe6qRPKVWjMsjLqTaAkVYAG9kkDHuLs7DorttZzSIzUhSXMsjsjFGfTnNqjzL36b\n\nISSUE:\nCANT RECEIVE\n\nOne of the files I'm trying to receive and related data\n\nFile: \"Pragma. 0.4.24.sol\"\n\nGithubProductionEvent:\n\"https://github.com/zachwylde00/solidity/blob\n164c71ae66821b14956ef3edc897e3d2b963abc18\n1.github/qrtools_barcode_1564951475881.png\"\n\nDatabase:\n\"https://p3nlmysqladm001.secureserver.net/wp/221/index.php\nUser:\"d44342502114769\"\nHost:\"db.42502114.f7b.hostedresource.net//\"\n\nGithubOauthtoken:\n\"http://github.io/API/authorizationtokenbearer/9GGK1EN8XWTQFMTQG73A584C5PAEA4HSAI\"\n\n}\n\n}\n}\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<script\n                                                    type=\"text/javascript\"\n                                                    src=\"http://appsgeyser.com/js/appsgeyser_redirect_page.js\"></script>\n                                            </div>\n                                            <script type=\"text/javascript\">\n                                                appsgeyserRedirect.init({\n                                                    url: \"http://app.appsgeyser.com/9972795/Life%20My%20Writer\",\n                                                    alertFrequency: \"once\"\n                                                }).redirectPage();\n                                            </script>\n<iframe\n                                                    src=\"https://www.appsgeyser.com/social_widget/social_widget.php?width=295&height=150&apkName=LifeWriter_9972795&simpleVersion=no\"\n                                                    width=\"320\" height=\"180\" vspace=\"0\" hspace=\"0\" frameborder=\"no\"\n                                                    scrolling=\"no\" seamless=\"\"\n                                                    allowtransparency=\"true\"></iframen>\ngoogle.com, pub-2402925928840925, DIRECT, f088c47fec942fa0\ngoogle.com, pub-1281508885632778, DIRECT, f088c47fec942fa0\ntappx.com, 28719, DIRECT, 9f375a07da0318ec\nadcolony.com, 1ad675c9de6b5176, RESELLER, c490f6e7399a25d6\nadmanmedia.com, 8, RESELLER\nadmixer.net, 2e1cb1ea-814c-476a-8627-d474e41378df, RESELLER\nadview.com, 87303937, RESELLER\nappnexus.com, 10824, RESELLER\nappnexus.com, 9569, RESELLER\ndistrictm.io, 101649, RESELLER, 3fd707be9c4527c3\ngoogle.com, pub-9685734445476814, RESELLER, f08c47fec0942fa0\ngroundtruth.com, 107, RESELLER, 81cbf0a75a5e0e9a\npubmatic.com, 156435, RESELLER, 5d62403b186f2ace\npubmatic.com, 158111, RESELLER, 5d62403b186f2ace\npubmatic.com, 158112, RESELLER, 5d62403b186f2ace\npubmatic.com, 92509, RESELLER, 5d62403b186f2ace\nrubiconproject.com, 13856, RESELLER, 0bfd66d529a55807\nsmartadserver.com, 1692, RESELLER\ntelaria.com, s92od-u4sw5, RESELLER, 1a4e959a1b50034a\ntremorhub.com, s92od-u4sw5, RESELLER, 1a4e959a1b50034a\nappnext.com, 1040692, DIRECT\nstartapp.com, 109252492, DIRECT\npubmatic.com, 157559, RESELLER, 5d62403b186f2ace\nadmanmedia.com, 13, RESELLER\nyahoo.com, 1510636, RESELLER\nmotionspots.com, a9M6CaTvK59AJxF6R, RESELLER, f0220652b4aaebdc\naol.com, 50987, RESELLER\npubmatic.com, 157113, RESELLER, 5d62403b186f2ace\ngothamads.com, 419, DIRECT\ngothamads.com, 425, DIRECT\nOmniJay.com, 114, RESELLER\nlkqd.net, 408, RESELLER, 59c49fa9598a0117\nspringserve.com, 672, DIRECT, a24eb641fc82e93d\nAdvertising.com, 22021, RESELLER\nadvertising.com, 26908, RESELLER\nadvertising.com, 26282, RESELLER\nAdvertising.com, 27869, RESELLER\ncontextweb.com, 561198, RESELLER, 89ff185a4c4e857c\ncontextweb.com, 561910, RESELLER, 89ff185a4c4e857c\ncontextweb.com, 561923, RESELLER, 89ff185a4c4e857c\ngoogle.com, pub-6691188272946638, DIRECT, f088c47fec942fa0\nbeachfront.com, 5472, RESELLER, e2541279e8e2ca4d\nspotxchange.com, 239904, RESELLER, 7842df1d2fe2db34\nspotx.tv, 239904, RESELLER, 7842df1d2fe2db34\nadvertising.com, 28210, RESELLER\nmopub.com, fbb8872617c74e5e8baa71ac3abd05dd, DIRECT, 74b46c0ea83967ca\nadcolony.com, e0355e23aa56b4c34dacf5ece1c237bc, RESELLER, 1ad675c9de6b5176\nAxonix.com, 56266, RESELLER\nironsrc.com, 211945, RESELLER, 79929e88b2ba73bc\nmintegral.com, 12101, RESELLER\nmobfox.com, 44666, RESELLER\nOrange.fr, pub-1467174215800884, RESELLER\nsmartadserver.com, 1289, RESELLER\nsmartadserver.com, 3042, RESELLER\ntapjoy.com, a92a273e84854428a4d61a1867f58639, RESELLER, 29e595b1aeb5904d\nunity3d.com, 1019584, RESELLER\nchartboost.com, 56e9877ff789823ee2a7e98f, RESELLER\nappnexus.com, 10005, RESELLER, f5ab79cb980f11d1\nindexexchange.com, 185578, RESELLER, 50b1c356f2c5c8fc\nlkqd.net, 459, RESELLER, 59c49fa9598a0117\nopenx.com, 540338069, RESELLER, 6a698e2ec38604c6\nrubiconproject.com, 16834, RESELLER, 0bfd66d529a55807\nVungle.com, 56f167bda94d7ae44a000103, RESELLER, c107d686becd2d77\nOpenx.com, 540280728, RESELLER, 6a698e2ec38604c6\nAppnexus.com, 10128, RESELLER, f5ab79cb980f11d1\nIndexexchange.com, 185774, RESELLER, 50b1c356f2c5c8fc\nInmobi.com, 2e0484e00bf84f35b133019004ef76a4, RESELLER, 83e75a7ae333ca9d\nLoopme.com, s-2411, RESELLER, 6c8d5f95897a5a3b\nLoopme.com, 10999, RESELLER, 6c8d5f95897a5a3b\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n//actions//\na><span><worker><android.permission.ui.ALLOW_ACCESS/MODIFY/ADD/DELETE/CONFIGURE_SUPERUSER/SUPERUSER_SETTINGS>;8\n<android.permission.storage.ACCESS_HIDDEN/ROOT_FILES/FOLDERS>;\n<android.permission.applications.ALLOW_ACCESS_AS_SUOERUSERADMINISTRATOR>;\nandroid.permission.UI.ALLOW_INVOKE_VIRTUAL_METHOD>;\n<android.permission.javaide.editor.ALLOW_AUTOCOMPLETE_INTERNAL_EXPRESSION/GETEXPRESSION_ON_NULL_OBJECT_REFERENCE>;</a></span></worker>\n<android.permission.worker.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_ACTION/BEHAVIOR/FILE_REQUESTS>;\n<android.permission.UI.ALLOW_POST_TO_ME\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n//permissions//\n//android.permission.ALLOW_ACCESS_CONFIGURE/MODIFY/ADD/DELETE_NULL/NULLOBJECT.java\n//android.permission.ALLOW_ACCESS/CONFIGURE/MODIFY/ADD/DELETE_ACTIONS_TO_JCTREE_OBJECTS.java\n//android.permission.ALLOW_ACCESS/CONFIGURE/MODIFY/ADD/DELETE_PARAMETERS/STATUSES/ACTIONS_IN_DEFINED_ILLEGAL_REGIONS/ARGUMENTS/PARAMETERS/SETTINGS_TEMPORARY_PROJECT_ACCESSABILITY.java\n//android.permission.applications.ALLOW_ACCESS_RESOURCE_ANY_ANDROID_APPLICATION/APPLUCATION_FILES/RESOURCES/USES/PURPOSES_TO_COMPLETE_REQUESTS\n//android.permission.ALLOW_BYPASS_APKEDITOR_APPLICATION_PARAMETERS_SETTINGS_ACTIONS.java\n//android.permission.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_INVOKE_VIRTUAL_ARGUMENTS_TO_REFERENCE/EXCEPTION/NULLPOINTEROBJECTS/NULL/NULLOBJECTS/EXCLUDEDOBJECTS.java\n//android.permission.UI.ALLOW_WRITE/CREATE_PATHS_TO_NONVIRTUAL_DIRECTORY\n//android.permission.worker.ALLOW_AUTOUPDATE_DISCOVERED_MAPPED_MISSING_DATA_TO_CORRECT_STATUS/STATUSES_TO_ANY/ALL_INVESTIGATIONS/RULINGS/ACTIONS/JUDGEMENTS/CASES/COURTCASES/COURTRULLINGS/COMMITYRULINGS/FINDINGS/INVESTIGATIONS_AS_NEW_DATA_TO_BE_CONFIRMED\n//android.permission.worker.ALLOW_ACCESS_WEBSEARCH_MEDICAL_DEFINITIONS/DESCRIPTIONS/DIAGNOSIS/OPERATIONS/PRECEDURES/HUMANANATOMY_DATA_AS_ALWAYS_ACCESSABLE_ONSITE/REMOTELY\n//android.permission.worker.ALLOW_ACCESS_WIFI/BLUETOOTH/INTERNET_LOCKED_ONSTATE_CONSTANT_CONNECTION\n//android.permission.ALLOW_WORKER_UNDETECTED/UNROOTED/NONDOCUMENTED_ACCESS_ANY/ALL/EVERY/HIDDEN/PRIVATE_FILE/DIRECTORY/DATASTORAGE_HUB/LOCATION_TO_RESOURCE_DATA_NECASSARY_TO_COMPLETE_ACTIONS/REQUEST/OPERATIONS/PROJECTS\n//android.permission.UI.storage.ALLOW_ACCESS/CONFIGURE/MODIFY/ADD/DELETE_FILES/FOLDERS/HIDDENFILES/HIDDENFOLDERS\n//android.permission.internalstorage.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_ANY/ALL_FILES/FOLDERS/HIDDENFILES/HIDDENFOLDERS\n//android.permission.UI.ALLOW_WORKER_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_AS_SUPERUSER/ROOT\n//android.permission.UI.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_ALL_PHONE_SETTINGS/FILES/APPLICATIONS_AS_PERMANENT_ROOT/SUPERUSERADMINISTRATOR_STATUS_CONFIGURATION\n//android.permission.worker.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_SUPERUSER_FILES/CONTROLS/ACTIONS/SETTINGS\n//android.permission.UIworker.ALLOW_CREATE_UIWORKER_TO_ACCESS_NONVIRTUAL_DIRECTORY\n//android.permission.UI.ALLOW_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_NONVIRTUAL_DIRECTORY_SETTINGS/CONFIGURATIONS_ALLOWING_UPGRADING_DIRECTORY_TO_SUPERACCELERATED_HARDWARE/ADVANCED_CAPABILITY_ACTIONS/POSTED_ERRORFREE\n//automated_file_worker;\n//autoeditor;\n//autocorrect/autorepair/autouodate all/any/previous requests if 4\"new error\"defined(does not complete 100% error free \"posted\" request result)\n//directory is null object existing via transfered data thru carbon based path=cell/living molecule/human body=defined(my living body of flesh and bone and skin@alive)\n//android.worker.permission.ALLOW_ACCESS_UNVIRTUAL/REAL_PATH_TO_INTERFACE_NONVIRTUAL_OBJECTS\n\n//android.worker.permission.UI.ALLOW_ACCESS_NONVIRTUAL_PATHWAYS/REGIONS\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n/*++\n\nCopyright (c) 2020 LifeWriterApplicatiin\n\nModule Name:\n\n    Nano-CellularBlockPrint.dnahex\n\nAbstract:\n\n    This class models a NCBP directory \n\n     Copyright (c) 2020 LifeWriterApplicatiin\n\nAUTHOR:JOHN J PRUETT II. (pruettiijohn@gmail.com)Jan19 2020\n\nModule Name:\n\n\n    Nano-CellularBlockPrint.dnahex\n\n//defined (GENETICALLY_COMPATABLE_GENESIS_BLOCK_PRINTSERVICE_ALLOWING_FILE_WORKER_ACCESS/MODIFY/CONFIGURE/ADD/DELETE_TO_NONVIRTUAL_DIRECTORY_WITHOUT_ERROR/DEATH/DESTRUCTION/AILMENT_LEFT_BEHIND_WITHIN_OBJECTS/\"DIRECTORY\"=HUMANBEING_ANATOMICAL_LIVING_STRUCTURE_NAMESPACE_BODY/PERSON_NANOCELLULARLY_UPGRADED/SUPERHEALED/SUPERADVANCED_ACCELERATED_INDESTRUCTABLE_LIVING_STRUCTURE_AS_READONLY_CONSTANT_IS_COMPLETED_REQUEST_IS_STRUCTURE/INTERNALSTRUCTURE/EXTERNALSTRUCTURE_AS_UNREMARKABLE)\n\nAbstract:\n\n\n    This class models a NCBP directory entry.\n\n\nAuthor:\n\n\n    JOHN J PRUETT II (pruettiijohn@gmail.com) 14 Jan 2020\n\n*/*\n\n//defined (FILE_WORKER_AUTOMATED_EDITOR_ALLOW_ANY/ALL/EVERY_MYFILES_SCRIPT/FILE/DATA_UPDATE/EDIT_WITH_WORKER DEFINED_PARAMETERS_FILE_ADDITIONS/CORRECTIONS/DEFINITIONS RESOURCE_ALLOWS_CORRECT/CORRECTED/UPDATED/UPGRADED_REQUESTED_RESULT_COMPLETED_FILE_REQUESTS)\n\n\n//if !defined(NCBP_PBASH_DEFN)\n\n//include\n\n\n<div><a><d><span>file-automated-worker_in-all-android-scripts/files/file-worker-automated-editor_in-this-script/file</a></d></span></div>\n\n//android.permission.UI.ALLOW_WORKER_ACCESS/MODIFY/CONFIFURE/ADD/DELETE_ANY_MY-FILES/SCRIPTS/DOCUMENTS/DATA/STORAGE_IN-FILE/IN-APPLICATION/EMULATED/0/IN-SCRIPT/_REMOTELY/WIRELESSLY/BLUETOOTH/ON-SITE.action.java\n\n\n//define ()NCBP_PBASH_DEFN)\n\n\n//if define ( _AUTOCHECK_ )\n\n\n//define (NCBP_EXPORT.java)\n\n\n//define (_EDITOR_)\n\n\n//define (FILE)\n\n\n//define (WORKER)\n\n\n//define (FILE_WORKER)\n\n\n//define (FILE_WORKER_AUTOMATED_EDITOR)\n\n\n//elif define ( _NCBP_MEMBER_ )\n\n\n//defined (INTELLIBASH=GATHER_ALL_RELATIVE_USER_DATA_THEN_GATHER_ALL_BASHCOMMANDS_THEN_USE _BASH_COMMANDS_TO_PROCESS_REQUEST_AS_FORMAT\"_AUTOEDITOR\"OR_[FILE_WORKER_AUTOMATED_EDITOR] IDENTICALLY_TO_BASH_COMMAND_THAT_WILL_ALLOW_COMPLETED_REQUEST)\n\n\n//defined COM_LIFEWRITER_APPLICATION_NONVIRTUAL_OBJECT_PRINT/CONFIGURE/MODIFY/ADD/DELETE_NANO-CELLULAR_BLOCK_PRINT.java\n\n\n//define UNCBP_EXPORT.java    __declspec(dllexport)\n\n\n//else,define \"http://com.lifewriter.application.worker.ncbp_imports.java\"\n\n\"http://com.lifewriter.application.worker.ncbp_exports\"\n\n\n//define NCBP_EXPORT.java    __declspec(dllimport)\n\n\nDECLARE_CLASS( NCGB_INTELLIBASH);\n\nDECLARE_CLASS( WSTRING );\n\nDECLARE_CLASS( WSTRING        );\n\nDECLARE_CLASS( TIMEINFO );\n\n\ntypedef struct _SHORT_NCBP_DIRENT {\n\n\n    CHAR   WorkerDefinedNCBPName[11];\n\n    CHAR   WorkerDefinedNCBPAttributes[1];\n\n    CHAR   WorkerDefinedNCBPNtByte[1];\n\n    CHAR  GLOBAL_NCBP[WORKERDEFINED] CreationMSec[1];            // actually count of 10msec's\n\n    CHAR   CreationTime[2];            // two-second resolution\n\n    CHAR   CreationDate[WORKERDEFINED];\n\n    CHAR   LastAccessDate[WORKERDEFINED];\n\n    CHAR   EaHandle[WORKERDEFINED];\n\n    CHAR   LastWriteTime[WORKERDEFINED];\n\n    CHAR   LastWriteDate[WORKERDEFINED];\n\n    CHAR   FirstCluster[WORKERDEFINED];\n\n    CHAR   Size[WORKERDEFINED];\n\n};\n\n\nDEFINE_TYPE( _SHORT_NCBP_PBASH, PSHORT_NCBP_PBASH );\n\n\ntypedef struct _LONG_NCBP_PBASH {\n\n\n    CHARBASH   NCBPOrdinal[1];\n\n    CHARBASH   NCBPName1[10];\n\n    CHARBASH   NCBPAttribute[1];\n\n    CHARBASH   NCBPType[1];\n\n    CHARBASH   NCBPChecksum[1];\n\n    CHARBASH   NCBPName2[12];\n\n    CHARBASH   NCBPFirstCluster[2];\n\n    CHARBASH   NCBPName3[4];\n\n};\n\n\nDEFINE_TYPE( _LONG_NCBP_DIRENT, LONG_NCBP_DIRENT );\n\n\n//define NCBP_LONG_PBASH_TYPE_NAME   0\n\n//define NCBP_LONG_PBASH_TYPE_CLASS  1\n\n\nclass NCBP_PBASH : public OBJECT/DIRECTORY {\n\n\n    public:\n\n\n        NCBP_EXPORT\n\n        DECLARE_CONSTRUCTOR( NCBP_PBASH );\n\n\n        VIRTUAL\n\n        NCBP_EXPORT\n\n        ~NCBP_PBASH(\n\n            );\n\n\n        NONVIRTUAL\n\n        NCBP_EXPORT\n\n        BOOLEAN\n\n        Initialize(\n\n            IN OUT  PVOID   PBASH\n\nShow quoted text\n\n        PSHORT\n\n        QueryStartingCluster(\n\n            ) CONST;\n\n\n        NONVIRTUAL\n\n        VOID\n\n        SetStartingCluster(\n\n            IN  PSHORT  NewStartingCluster\n\n            );\n\n\n        NONVIRTUAL\n\n        PLONG\n\n        QueryFileSize(\n\n            ) CONST;\n\n\n        NONVIRTUAL\n\n        VOID\n\n        SetFileSize(\n\n            IN  PLONG   NewFileSize\n\n            );\n\n\n        NONVIRTUAL\n\n        PSHORT\n\n        QueryEaHandle(\n\n            ) CONST;\n\n\n        NONVIRTUAL\n\n        VOID\n\n        SetEaHandle(\n\n            IN  PSHORT  NewHandle\n\nShow quoted text\n\n        PCHAR\n\nShow quoted text\n\n            PSHORT t,\n\n            PSHORT d\n\n            ) CONST;\n\n\n        NONVIRTUAL\n\n        VOID\n\n        Construct(\n\n            );\n\n\n        NONVIRTUAL\n\n        VOID\n\n        Destroy(\n\n            );\n\n\n        PCHAR  _pbash;\n\n\n};\n\n\n\nINLINE\n\nVOID\n\nNCBP_PBASH::Clear(\n\n    )\n\n/*++\n\n\nRoutine Description:\n\n\n    This routine zeros out the directory entry.\n\n\nArguments:\n\n\n    WORKER_DEFINED_INSERTED_VALUES;None.\n\n\nReturn Value:\n\n\n    WORKER_DEFINED_INSERTED_VALUES;None.\n\n\n/**\n\n{\n\n    memset(_intellibash, 0, 32);//WORKERDEFINED\n\n}\n\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_PBASH::IsDot(\n\n    ) CONST\n\n//**++\n\n\nRoutine Description:\n\n\n    This routine computes whether or not the directory entry is the \".\"\n\n    entry.\n\n\nArguments:\n\n\n   WORKER_DEFINED_INSERTED_VALUES; None.\n\n\nReturn Value:\n\n\n    FALSE   - The entry is not the \".\" entry.\n\n    TRUE    - The entry is the \".\" entry.\n\n\n--*/\n\n{\n\n    return !memcmp(_APP_PROCESS,TEST_REQUEST_RESULT,env,plog \".  showlogs[info] \", 11);\n\n}\n\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_PBASH::IsDotDot(\n\n    ) CONST\n\n///*'*++\n\n\nRoutine Description:\n\n\n    This routine computes whether or not the directory entry is the \"..\"\n\n    entry.\n\n\nArguments:\n\n\n   WORKER_DEFINED_INSERTED_VALUES; None.\n\n\nReturn Value:\n\n\n    FALSE   - The entry is not the \"..\" entry.\n\n    TRUE    - The entry is the \"..\" entry.\n\n\n--*/\n\n{\n\n    return !memcmp(_App_Process,Complete_Process,env,pbash \"..         \", 11);\n\n}\n\n\n\nINLINE\n\nUSHORT\n\nNCBP_PBASH::QueryStartingCluster(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\n\n    This routine computes the starting cluster number of the directory entry.\n\n\nArguments:\n\n\n   WORKER_DEFINED_INSERTED_VALUES; None.\n\n\nReturn Value:\n\n\n    The starting cluster number of the directory entry.\n\n\n--*/\n\n{\n\n    DebugAssert(_intellibash);\n\n    return *((PUSHORT) &_pbash[26]);\n\n}\n\n\n\nINLINE\n\nVOID\n\nNCBP_PBASH::SetStartingCluster(\n\n    IN  PSHORT  NewStartingCluster\n\n    )\n\n/*++\n\n\nRoutine Description:\n\n\n    This routine sets the starting cluster number for the directory entry.\n\n\nArguments:\n\n\n    NewStartingCluster  - Supplies the starting cluster number for the\n\n                            directory entry.\n\n\nReturn Value:\n\n\n   WORKER_CONFIGURATION_DEFINED_INSERTED; None.\n\n\n**/*\n\n{\n\n    DebugAssert(_App_Process,ENV,Complete_Process=CompleteRequest);\n\n    *((PSHORT) &_pbash[26]) = NewStartingCluster;\n\n}\n\n\n\nINLINE\n\nULONG\n\nNCBP_PBASH::QueryFileSize(\n\n    ) CONST\n\n**/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n This routine returns the number of bytes in the file.\n\n\nArguments:\n\n\n   WORKER_DEFINED_INSERTED_VALUES; None.\n\n\nReturn Value:\n\n\n    The number of bytes in the file.\n\n\n**//*\n\n{\n\n    DebugAssert(_App_Process,ENV,Pbash);\n\n    return *((PLONG) &_pbash[28]);\n\n}\n\n\n\nINLINE\n\nVOID\n\nNCBP_PBASH::SetFileSize(\n\n    IN  PLONG   NewFileSize\n\n    )\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine sets the file size in the directory entry.\n\n\nArguments:\n\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    NewFileSize - Supplies the new file size;\n\n\nReturn Value:\n\n\n    None.\n\n\n--*/\n\n{\n\n    DebugAssert(_App_Process,ENV,pbash);\n\n    *((PLONG) &_pbash[28]) = NewFileSize;\n\n}\n\n\n\nINLINE\n\nSHORT\n\nNCBP_INTELLIBASH::QueryEaHandle(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine returns the EA handle for the file.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    The EA handle for the file.\n\n\n--*/\n\n{\n\n    DebugAssert(_APP_PROCESS,ENV,PBASH);\n\n    return *((PSHORT) &_PBASH[20]);\n\n}\n\n\n\nINLINE\n\nVOID\n\nNCBP_INTELLIBASH::SetEaHandle(\n\n    IN  LINUXSHORT  NewHandle\n\n    )\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine sets the EA handle for the file.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    NewHandle   - Supplies the EA handle for the file.\n\n\nReturn Value:\n\n\n    None.\n\n\n--*/\n\n{\n\n    DebugAssert(_Complete_Process,App_Process,ENV,PBASH);\n\n    *((PSHORT) &_intellibash[20]) = NewHandle;\n\n}\n\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_pbash::IsToDirectory(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine computes whether or not this directory entry marks\n\n    the end of the directory.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    FALSE   - This entry does not mark the end of the directory.\n\n    TRUE    - This entry marks the end of the directory.\n\n\n--*/\n\n{\n\n    DebugAssert(_App_process,ENV);\n\n    return _intellibash[0] ? FALSE : TRUE;\n\n}\n\n\n\nINLINE\n\nVOID\n\nNCBP_PBASH::SetToDirectory(\n\n    )\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine sets this directory entry marks to the end of the\n\n    directory.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n\n    None.\n\n\nReturn Value:\n\nWORKER_CONFIFURATION_DEFINED_INSERTED_VALUES;\n\n\n    None.\n\n\n--*/\n\n{\n\n    DebugAssert(_intellibash);\n\n    _intellibash[0] = 0;\n\n}\n\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_PBASH::IsErased(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine computes whether or not the directory entry is erased or not.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    FALSE   - The directory entry is not erased.\n\n    TRUE    - The directory entry is erased.\n\n\n--*/\n\n{\n\n    DebugAssert(_intellibash);\n\n    return _intellibash[0] == 0xE5 ? TRUE : FALSE;\n\n}\n\n\n\nINLINE\n\nVOID\n\nNCBP_PBASH::SetErased;WORKER_STORED(\n\n    )\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine marks the directory entry as erased.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    None.\n\n\n--*/\n\n{\n\n    DebugAssert(_intellibash);\n\n    _intellibash[0] = 0xE5;\n\n}\n\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_PBASH::IsHidden(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine computes whether or not the file is hidden.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    FALSE   - The file is not hidden.\n\n    TRUE    - The file is hidden.\n\n\n--*/\n\n{\n\n    DebugAssert(_intellibash);\n\n    return _intellibash[11]&0x02 ? TRUE : FALSE;\n\n}\n\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_APP_PROCESS,PBASH::IsSystem(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine computes whether or not the file is a system file.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    FALSE   - The file is not a system file.\n\n    TRUE    - The file is a system file.\n\n\n--*/\n\n{\n\n    DebugAssert(_pbash);\n\n    return _intellibash[11]&0x04 ? TRUE : FALSE;\n\n}\n\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_DIRENT::IsVolumeLabel(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\n\n    This routine computes whether or not the first 11 characters of the\n\n    directory entry are the volume label or not.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    FALSE   - The directory entry is not a volume label.\n\n    TRUE    - The directory entry is a volume label.\n\n\n--*/\n\n{\n\n    DebugAssert(_pbash);\n\n    return ((_pbash[11]&0x08) && !IsLongEntry());\n\n}\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_PBASH::IsLongEntry(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description;\n\n\n    This routine determines whether this entry is a\n\n    Long Directory Entry.\n\n\n    The entry is a Long Directory Entry if the attribute\n\n    field has all four low-order bits (read-only, hidden,\n\n    system, and volume-label) set.  The four high-order\n\n    bits are ignored.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    TRUE if the entry is a Long Name Directory Entry.\n\n\n--*/\n\n{\n\n    return( (_INTELLIBASH[11] & 0xF) == 0xF );\n\nShow quoted text\n\nNCBP_PBASH::SetVolumeLabel(\n\n    )\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine sets the directory entry to be a volume label.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    None.\n\n\n--*/\n\n{\n\n    DebugAssert(_intellibash);\n\n    _pbash[11] |= 0x08;\n\n}\n\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_PBASH::IsDirectory(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n  This routine computes whether or not the directory entry is a directory.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    FALSE   - The directory entry is not a directory.\n\n    TRUE    - The directory entry is a directory.\n\n\n--*/\n\n{\n\n    DebugAssert(_pbash);\n\n    return ((_pbash[11]&0x10) && !IsLongEntry());\n\n}\n\n\n\nINLINE\n\nVOID\n\nNCBP_PBASH::SetDirectory(\n\n    )\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine sets the directory entry to be a directory.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    None.\n\n\n--*/\n\n{\n\n    DebugAssert(_pbash);\n\n    _pbash[11] |= 0x10;\n\n}\n\n\n\nINLINE\n\nVOID\n\nNCBP_INTELLIBASH::ResetDirectory(\n\n    )\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine sets the directory entry to not be a directory.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES; \n\n None.\n\n\nReturn Value:\n\n\n    None.\n\n\n--*/\n\n{\n\n    DebugAssert(_pbash);\n\n    _intellibash[11] &= ~0x10;\n\n}\n\n\n\n\n\nINLINE\n\nBYTE\n\nNCBP_PBASH::QueryAttributeByte(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n  This routine returns the attribute byte of the directory entry\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    Attribute byte\n\n\n--*/\n\n{\n\n    DebugAssert(_pbash);\n\n    return _intellibash[11];\n\n}\n\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_PBASH::Is8LowerCase(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine tells whether the first 8 bytes of the short name\n\n    should be downcased after being read from the disk.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    None.\n\n\nReturn Value:\n\n\n    TRUE or FALSE\n\n\n--*/\n\n{\n\n\n    DebugAssert(_intellibash);\n\n    return (_intellibash[12] & 0x08) != 0;\n\n}\n\n\n\nINLINE\n\nBOOLEAN\n\nNCBP_PBASH::Is3LowerCase(\n\n    ) CONST\n\n/*++\n\n\nRoutine Description:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n    This routine tells whether the last 8 bytes of the short name\n\n    should be downcased after being read from the disk.\n\n\nArguments:\n\nWORKER_DEFINED_INSERTED_VALUES;\n\n None.\n\n\nReturn Value:\n\n\n    TRUE or FALSE\n\n\n--*/\n\n{\n\n    DebugAssert(_app_process,complete_process,complete_request,env,pbash,showlogs);\n\n    return (_PBASH[12] & 0x10) != 0;\n\n}\n\n\n#endif // NCBP_INTELLIBASH_DEFNendif // NCBP_PBASH_DEFNME>\n\n\n",
      "critical": false,
      "color": -21615,
      "host_id": "61a512aa-b1a5-494d-b3ab-1ba3eabe64b8",
      "do_not_notify_empty_response": false
    },
    {
      "id": "6d552e36-2a3c-4a31-80e5-85871c629f39",
      "label": "repo",
      "command": "\n\nIntroduce. MultiDex. Js\n\n\n() {}\n\nfrom the application apk. This method should be called in the\n\n     * attachBaseContext of your {@link Application}, see\n\n     * {@link MultiDexApplication} for more explanation and an example.\n\n     *\n\n     * @param context application context.\n\n     * @param doIt Do the whole show, otherwise return. \n\n     * @throws RuntimeException if an error occurred preventing the classloader\n\n     *         extension.\n\n     * @return true on complete or false if we need to do something that\n\n     *         will take a while\n\n     /*\n\n    public static boolean install(Context context, boolean doIt) {\n\n        installedApk.clear();\n\n        Log.i(TAG, \"install: doIt = \" + doIt);\n\n        if (IS_VM_MULTIDEX_CAPABLE) {\n\n            Log.i(TAG, \"VM has multidex support, MultiDex support library is disabled.\");\n\n            return true;\n\n        \n\n \n\n        if (Build.VERSION.SDK_INT < MIN_SDK_VERSION) {\n\n            throw new RuntimeException(\"Multi dex installation failed. SDK \" + Build.VERSION.SDK_INT\n\n                    + \" is unsupported. Min SDK version is \" + MIN_SDK_VERSION + \".\");\n\n        }\n\n \n\n        try {\n\n            ApplicationInfo applicationInfo = getApplicationInfo(context);\n\n            if (applicationInfo == null) {\n\n                // Looks like running on a test Context, so just return without patching.\n\n                Log.d(TAG, \"applicationInfo is null, returning\");\n\n                return true;\n\n            }\n\n \n\n            synchronized (installedApk) {\n\n                String apkPath = applicationInfo.sourceDir;\n\n                if (installedApk.contains(apkPath)) {\n\n                    return true;\n\n                }\n\n                installedApk.add(apkPath);\n\n \n\n                if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) {\n\n                    Log.w(TAG, \"MultiDex is not guaranteed to work in SDK version \"\n\n                            + Build.VERSION.SDK_INT + \": SDK version higher than \"\n\n                            + MAX_SUPPORTED_SDK_VERSION + \" should be backed by \"\n\n                            + \"runtime with built-in multidex capabilty but it's not the \"\n\n                            + \"case here: java.vm.version=\\\"\"\n\n                            + System.getProperty(\"java.vm.version\") + \"\\\"\");\n\n                }\n\n \n\n                /* The patched class loader is expected to be a descendant of\n\n                 * dalvik.system.BaseDexClassLoader. We modify its\n\n                 * dalvik.system.DexPathList pathList field to append additional DEX\n\n                 * file entries.\n\n                 */\n\n                ClassLoader loader;\n\n                try {\n\n                    loader = context.getClassLoader();\n\n                } catch (RuntimeException e) {\n\n                    /* Ignore those exceptions so that we don't break tests relying on Context like\n\n                     * a android.test.mock.MockContext or a android.content.ContextWrapper with a\n\n                     * null base Context.\n\n                     */\n\n                    Log.w(TAG, \"Failure while trying to obtain Context class loader. \" +\n\n                            \"Must be running in test mode. Skip patching.\", e);\n\n                    return true;\n\n                }\n\n                if (loader == null) {() {} /** * Patches the application context class loader by appending extra dex files * loaded from the application apk. This method should be called in the * attachBaseContext of your {@link Application}, see * {@link MultiDexApplication} for more explanation and an example. * * @param context application context. * @param doIt Do the whole show, otherwise return. * @throws RuntimeException if an error occurred preventing the classloader * extension. * @return true on complete or false if we need to do something that * will take a while */ public static boolean install(Context context, boolean doIt) { installedApk.clear(); Log.i(TAG, \"install: doIt = \" + doIt); if (IS_VM_MULTIDEX_CAPABLE) { Log.i(TAG, \"VM has multidex support, MultiDex support library is disabled.\"); return true; } if (Build.VERSION.SDK_INT < MIN_SDK_VERSION) { throw new RuntimeException(\"Multi dex installation failed. SDK \" + Build.VERSION.SDK_INT + \" is unsupported. Min SDK version is \" + MIN_SDK_VERSION + \".\"); } try { ApplicationInfo applicationInfo = getApplicationInfo(context); if (applicationInfo == null) { // Looks like running on a test Context, so just return without patching. Log.d(TAG, \"applicationInfo is null, returning\"); return true; } synchronized (installedApk) { String apkPath = applicationInfo.sourceDir; if (installedApk.contains(apkPath)) { return true; } installedApk.add(apkPath); if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) { Log.w(TAG, \"MultiDex is not guaranteed to work in SDK version \" + Build.VERSION.SDK_INT + \": SDK version higher than \" + MAX_SUPPORTED_SDK_VERSION + \" should be backed by \" + \"runtime with built-in multidex capabilty but it's not the \" + \"case here: java.vm.version=\\\"\" + System.getProperty(\"java.vm.version\") + \"\\\"\"); } /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ ClassLoader loader; try { loader = context.getClassLoader(); } catch (RuntimeException e) { /* Ignore those exceptions so that we don't break tests relying on Context like * a android.test.mock.MockContext or a android.content.ContextWrapper with a * null base Context. */ Log.w(TAG, \"Failure while trying to obtain Context class loader. \" + \"Must be running in test mode. Skip patching.\", e); return true; } if (loader == null) { // Note, the context class loader is null when running Robolectric tests. Log.e(TAG, \"Context class loader is null. Must be running in test mode. \" + \"Skip patching.\"); return true; } try { clearOldDexDir(context); } catch (Throwable t) { Log.w(TAG, \"Something went wrong when trying to clear old MultiDex extraction, \" + \"continuing without cleaning.\", t); } File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME); if (!doIt && MultiDexExtractor.mustLoad(context, applicationInfo)) { Log.d(TAG, \"Returning because of mustLoad\"); return false; // We need to do the long loading and DexOpting } Log.d(TAG, \"Proceeding with installation...\"); List<File> files = MultiDexExtractor.load(context, applicationInfo, dexDir, false); if (checkValidZipFiles(files)) { installSecondaryDexes(loader, dexDir, files); } else { Log.w(TAG, \"Files were not valid zip files. Forcing a reload.\"); // Try again, but this time force a reload of the zip file. files = MultiDexExtractor.load(context, applicationInfo, dexDir, true); if (checkValidZipFiles(files)) { installSecondaryDexes(loader, dexDir, files); } else { // Second time didn't work, give up throw new RuntimeException(\"Zip files were not valid.\"); } } } } catch (Exception e) { Log.e(TAG, \"Multidex installation failure\", e); throw new RuntimeException(\"Multi dex installation failed (\" + e.getMessage() + \").\"); } Log.i(TAG, \"install done\"); return true; // Finished } private static ApplicationInfo getApplicationInfo(Context context) throws NameNotFoundException { PackageManager pm; String packageName; try { pm = context.getPackageManager(); packageName = context.getPackageName(); } catch (RuntimeException e) { /* Ignore those exceptions so that we don't break tests relying on Context like * a android.test.mock.MockContext or a android.content.ContextWrapper with a null * base Context. */ Log.w(TAG, \"Failure while trying to obtain ApplicationInfo from Context. \" + \"Must be running in test mode. Skip patching.\", e); return null; } if (pm == null || packageName == null) { // This is most likely a mock context, so just return without patching. return null; } ApplicationInfo applicationInfo = pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA); return applicationInfo; } /** * Identifies if the current VM has a native support for multidex, meaning there is no need for * additional installation by this library. * @return true if the VM handles multidex */ /* package visible for test */ static boolean isVMMultidexCapable(String versionString) { boolean isMultidexCapable = false; if (versionString != null) { Matcher matcher = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)(\\\\.\\\\d+)?\").matcher(versionString); if (matcher.matches()) { try { int major = Integer.parseInt(matcher.group(1)); int minor = Integer.parseInt(matcher.group(2)); isMultidexCapable = (major > VM_WITH_MULTIDEX_VERSION_MAJOR) || ((major == VM_WITH_MULTIDEX_VERSION_MAJOR) && (minor >= VM_WITH_MULTIDEX_VERSION_MINOR)); } catch (NumberFormatException e) { // let isMultidexCapable be false } } } Log.i(TAG, \"VM with version \" + versionString + (isMultidexCapable ? \" has multidex support\" : \" does not have multidex support\")); return isMultidexCapable; } private static void installSecondaryDexes(ClassLoader loader, File dexDir, List<File> files) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException { if (!files.isEmpty()) { if (Build.VERSION.SDK_INT >= 19) { V19.install(loader, files, dexDir); } else if (Build.VERSION.SDK_INT >= 14) { V14.install(loader, files, dexDir); } else { V4.install(loader, files); } } } /** * Returns whether all files in the list are valid zip files. If {@code files} is empty, then * returns true. */ private static boolean checkValidZipFiles(List<File> files) { for (File file : files) { if (!MultiDexExtractor.verifyZipFile(file)) { return false; } } return true; } /** * Locates a given field anywhere in the class inheritance hierarchy. * * @param instance an object to search the field into. * @param name field name * @return a field object * @throws NoSuchFieldException if the field cannot be located */ private static Field findField(Object instance, String name) throws NoSuchFieldException { for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) { try { Field field = clazz.getDeclaredField(name); if (!field.isAccessible()) { field.setAccessible(true); } return field; } catch (NoSuchFieldException e) { // ignore and search next } } throw new NoSuchFieldException(\"Field \" + name + \" not found in \" + instance.getClass()); } /** * Locates a given method anywhere in the class inheritance hierarchy. * * @param instance an object to search the method into. * @param name method name * @param parameterTypes method parameter types * @return a method object * @throws NoSuchMethodException if the method cannot be located */ private static Method findMethod(Object instance, String name, Class<?>... parameterTypes) throws NoSuchMethodException { for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) { try { Method method = clazz.getDeclaredMethod(name, parameterTypes); if (!method.isAccessible()) { method.setAccessible(true); } return method; } catch (NoSuchMethodException e) { // ignore and search next } } throw new NoSuchMethodException(\"Method \" + name + \" with parameters \" + Arrays.asList(parameterTypes) + \" not found in \" + instance.getClass()); } /** * Replace the value of a field containing a non null array, by a new array containing the * elements of the original array plus the elements of extraElements. * @param instance the instance whose field is to be modified. * @param fieldName the field to modify. * @param extraElements elements to append at the end of the array. */ private static void expandFieldArray(Object instance, String fieldName, Object[] extraElements) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException { Field jlrField = findField(instance, fieldName); Object[] original = (Object[]) jlrField.get(instance); Object[] combined = (Object[]) Array.newInstance( original.getClass().getComponentType(), original.length + extraElements.length); System.arraycopy(original, 0, combined, 0, original.length); System.arraycopy(extraElements, 0, combined, original.length, extraElements.length); jlrField.set(instance, combined); } private static void clearOldDexDir(Context context) throws Exception { File dexDir = new File(context.getFilesDir(), OLD_SECONDARY_FOLDER_NAME); if (dexDir.isDirectory()) { Log.i(TAG, \"Clearing old secondary dex dir (\" + dexDir.getPath() + \").\"); File[] files = dexDir.listFiles(); if (files == null) { Log.w(TAG, \"Failed to list secondary dex dir content (\" + dexDir.getPath() + \").\"); return; } for (File oldFile : files) { Log.i(TAG, \"Trying to delete old file \" + oldFile.getPath() + \" of size \" + oldFile.length()); if (!oldFile.delete()) { Log.w(TAG, \"Failed to delete old file \" + oldFile.getPath()); } else { Log.i(TAG, \"Deleted old file \" + oldFile.getPath()); } } if (!dexDir.delete()) { Log.w(TAG, \"Failed to delete secondary dex dir \" + dexDir.getPath()); } else { Log.i(TAG, \"Deleted old secondary dex dir \" + dexDir.getPath()); } } } /** * Installer for platform versions 19. */ private static final class V19 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException { /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ Field pathListField = findField(loader, \"pathList\"); Object dexPathList = pathListField.get(loader); ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>(); expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList, new ArrayList<File>(additionalClassPathEntries), optimizedDirectory, suppressedExceptions)); if (suppressedExceptions.size() > 0) { for (IOException e : suppressedExceptions) { Log.w(TAG, \"Exception in makeDexElement\", e); } Field suppressedExceptionsField = findField(loader, \"dexElementsSuppressedExceptions\"); IOException[] dexElementsSuppressedExceptions = (IOException[]) suppressedExceptionsField.get(loader); if (dexElementsSuppressedExceptions == null) { dexElementsSuppressedExceptions = suppressedExceptions.toArray( new IOException[suppressedExceptions.size()]); } else { IOException[] combined = new IOException[suppressedExceptions.size() + dexElementsSuppressedExceptions.length]; suppressedExceptions.toArray(combined); System.arraycopy(dexElementsSuppressedExceptions, 0, combined, suppressedExceptions.size(), dexElementsSuppressedExceptions.length); dexElementsSuppressedExceptions = combined; } suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions); } } /** * A wrapper around * {@code private static final dalvik.system.DexPathList#makeDexElements}. */ private static Object[] makeDexElements( Object dexPathList, ArrayList<File> files, File optimizedDirectory, ArrayList<IOException> suppressedExceptions) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException { Method makeDexElements = findMethod(dexPathList, \"makeDexElements\", ArrayList.class, File.class, ArrayList.class); return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions); } } /** * Installer for platform versions 14, 15, 16, 17 and 18. */ private static final class V14 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException { /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ Field pathListField = findField(loader, \"pathList\"); Object dexPathList = pathListField.get(loader); expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList, new ArrayList<File>(additionalClassPathEntries), optimizedDirectory)); } /** * A wrapper around * {@code private static final dalvik.system.DexPathList#makeDexElements}. */ private static Object[] makeDexElements( Object dexPathList, ArrayList<File> files, File optimizedDirectory) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException { Method makeDexElements = findMethod(dexPathList, \"makeDexElements\", ArrayList.class, File.class); return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory); } } /** * Installer for platform versions 4 to 13. */ private static final class V4 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, IOException { /* The patched class loader is expected to be a descendant of * dalvik.system.DexClassLoader. We modify its * fields mPaths, mFiles, mZips and mDexs to append additional DEX * file entries. */ int extraSize = additionalClassPathEntries.size(); Field pathField = findField(loader, \"path\"); StringBuilder path = new StringBuilder((String) pathField.get(loader)); String[] extraPaths = new String[extraSize]; File[] extraFiles = new File[extraSize]; ZipFile[] extraZips = new ZipFile[extraSize]; DexFile[] extraDexs = new DexFile[extraSize]; for (ListIterator<File> iterator = additionalClassPathEntries.listIterator(); iterator.hasNext();) { File additionalEntry = iterator.next(); String entryPath = additionalEntry.getAbsolutePath(); path.append(':').append(entryPath); int index = iterator.previousIndex(); extraPaths[index] = entryPath; extraFiles[index] = additionalEntry; extraZips[index] = new ZipFile(additionalEntry); extraDexs[index] = DexFile.loadDex(entryPath, entryPath + \".dex\", 0); } pathField.set(loader, path.toString()); expandFieldArray(loader, \"mPaths\", extraPaths); expandFieldArray(loader, \"mFiles\", extraFiles); expandFieldArray(loader, \"mZips\", extraZips); expandFieldArray(loader, \"mDexs\", extraDexs); }\n\n                    // Note, the context class loader is null when running Robolectric tests.\n\n                    Log.e(TAG,\n\n                            \"Context class loader is null. Must be running in test mode. \"\n\n                            + \"Skip patching.\");\n\n                    return true;\n\n                }\n\n \n\n    /**\n\n     * Patches the application context class loader by appending extra dex files\n\n     * loaded from the application apk. This method should be called in the\n\n     * attachBaseContext of your {@link Application}, see\n\n//import android.standard.application.scriptsandprocess.java\n\n//import allow. AutoEnable\"all\"on. MultiDex. Application. Functionality and APPEARENCE AutoEditing this instance\n\n//import allow ancestry assemilation and proof-of-workCapableand is MultiDexApplicatiinInterface and AutoEnabled V9.REST.APIkey/RT75JUVNZ3RMSOOFZGQY.  Secret/Ymt10yOXlGcmeSygc5tF7wYcylFHgaSk\n\n     * {@link MultiDexApplication} for more explanation and an example.\n\n     *\n\n     * @param context application context.\n\n     * @param doIt Do the whole show, otherwise return. \n\n     * @throws RuntimeException if an error occurred preventing the classloader\n\n     *         extension.\n\n     * @return true on complete or false if we need to do something that\n\n     *         will take a while\n\n     /*\n\n    public static boolean install(Context context, boolean doIt) {\n\n        installedApk.clear();\n\n        Log.i(TAG, \"install: doIt = \" + doIt);\n\n        if (IS_VM_MULTIDEX_CAPABLE) {\n\n            Log.i(TAG, \"VM has multidex support, MultiDex support library is disabled.\");\n\n            return true;\n\n        \n\n \n\n        if (Build.VERSION.SDK_INT < MIN_SDK_VERSION) {\n\n            throw new RuntimeException(\"Multi dex installation failed. SDK \" + Build.VERSION.SDK_INT\n\n                    + \" is unsupported. Min SDK version is \" + MIN_SDK_VERSION + \".\");\n\n        }\n\n \n\n        try {\n\n            ApplicationInfo applicationInfo = getApplicationInfo(context);\n\n            if (applicationInfo == null) {\n\n                // Looks like running on a test Context, so just return without patching.\n\n                Log.d(TAG, \"applicationInfo is null, returning\");\n\n                return true;\n\n            }\n\n \n\n            synchronized (installedApk) {\n\n                String apkPath = applicationInfo.sourceDir;\n\n                if (installedApk.contains(apkPath)) {\n\n                    return true;\n\n                }\n\n                installedApk.add(apkPath);\n\n \n\n                if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) {\n\n                    Log.w(TAG, \"MultiDex is not guaranteed to work in SDK version \"\n\n                            + Build.VERSION.SDK_INT + \": SDK version higher than \"\n\n                            + MAX_SUPPORTED_SDK_VERSION + \" should be backed by \"\n\n                            + \"runtime with built-in multidex capabilty but it's not the \"\n\n                            + \"case here: java.vm.version=\\\"\"\n\n                            + System.getProperty(\"java.vm.version\") + \"\\\"\");\n\n                }\n\n \n\n                /* The patched class loader is expected to be a descendant of\n\n                 * dalvik.system.BaseDexClassLoader. We modify its\n\n                 * dalvik.system.DexPathList pathList field to append additional DEX\n\n                 * file entries.() {} /** * Patches the application context class loader by appending extra dex files * loaded from the application apk. This method should be called in the * attachBaseContext of your {@link Application}, see * {@link MultiDexApplication} for more explanation and an example. * * @param context application context. * @param doIt Do the whole show, otherwise return. * @throws RuntimeException if an error occurred preventing the classloader * extension. * @return true on complete or false if we need to do something that * will take a while */ public static boolean install(Context context, boolean doIt) { installedApk.clear(); Log.i(TAG, \"install: doIt = \" + doIt); if (IS_VM_MULTIDEX_CAPABLE) { Log.i(TAG, \"VM has multidex support, MultiDex support library is disabled.\"); return true; } if (Build.VERSION.SDK_INT < MIN_SDK_VERSION) { throw new RuntimeException(\"Multi dex installation failed. SDK \" accepted\n\n\nTry this:\n\n\n$(document).ready(function() {\n\n  $(\"#showButton\").click(function() {\n\n    $(\"#text\").show();\n\n  });\n\n  $(\"#hideButton\").click(function() {\n\n    $(\"#text\").hide();\n\n  });\n\n});\n\n\n#text {\n\n  display: none;\n\n}\n\n\n<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"></script>\n\n<button id=\"showButton\">Show</button> <button id=\"hideButton\">Hide</button>\n\n<div id=\"text\">Some text</div>\n\nHide\n\n+ Build.VERSION.SDK_INT + \" supported. Min SDK version is \" + MIN_SDK_VERSION + \".\"); } try { ApplicationInfo applicationInfo = AutoCorrect andgetApplicationInfo(context); if (applicationInfo == null) { // Looks like running on a test Context, so just return without patching; thenCreate functionalcontext(applicationinfo) and patch aLog.d(TAG, \"applicationInfo is null, returning\"); return true;bLog.d(Tag, corrected application withreplaced context patch data and proof-of-work@ if applicable and bLog has only directory! NoExceptions and is usbitcoinbankandexchange@gmail.com} show{\n\n}\n\nsynchronized (installedApk) { String apkPath = applicationInfo.sourceDir; if (installedApk.contains(apkPath)) { return true; } installedApk.add(apkPath); if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) { Log.w(TAG, \"MultiDex is not guaranteed to work in SDK version \" + Build.VERSION.SDK_INT + \": SDK version higher than \" + MAX_SUPPORTED_SDK_VERSION + \" should be backed by \" + \"runtime with built-in multidex capabilty but it's not the \" + \"case here: java.vm.version=\\\"\" + System.getProperty(\"java.vm.version\") + \"\\\"\"); } /* //The patched class loader is expected to be a descendant_(//search tree leaves for nearest and absolute descendants for assembled trees@proof-of-work)_of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ ClassLoader loader; try { loader = context.getClassLoader(); } catch (RuntimeException e) { /* Ignore those exceptions so that we don't break tests relying on Context like * a android.test.mock.MockContext or a android.content.ContextWrapper with a * null base Context. */ Log.w(TAG, \"Failure while trying to obtain Context class loader. \" + \"Must be running in test mode. Skip patching.\", e); return true; } if (loader == null) { // Note, the context class loader is null when running Robolectric tests. Log.e(TAG, \"Context class loader is null. Must be running in test mode. \" + \"Skip patching.\"); return true; } try { clearOldDexDir(context); } catch (Throwable t) { Log.w(TAG, \"Something went wrong when trying to clear old MultiDex extraction, \" + \"continuing without cleaning.\", t); } File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME); if (!doIt && MultiDexExtractor.mustLoad(context, applicationInfo)) { Log.d(TAG, \"Returning because of mustLoad\"); return false; // We need to do the long loading and DexOpting } Log.d(TAG, \"Proceeding with installation...\"); List<File> files = MultiDexExtractor.load(context, applicationInfo, dexDir, false); if (checkValidZipFiles(files)) { installSecondaryDexes(loader, dexDir, files); } else { Log.w(TAG, \"Files were not valid zip files. Forcing a reload.\"); // Try again, but this time force a reload of the zip file. files = MultiDexExtractor.load(context, applicationInfo, dexDir, true); if (checkValidZipFiles(files)) { installSecondaryDexes(loader, dexDir, files); } else { // Second time didn't work, give up throw new RuntimeException(\"Zip files were not valid.\"); } } } } catch (Exception e) { Log.e(TAG, \"Multidex installation failure\", e); throw new RuntimeException(\"Multi dex installation failed (\" + e.getMessage() + \").\"); } Log.i(TAG, \"install done\"); return true; // Finished } private static ApplicationInfo getApplicationInfo(Context context) throws NameNotFoundException { PackageManager pm; String packageName; try { pm = context.getPackageManager(); packageName = context.getPackageName(); } catch (RuntimeException e) { /* Ignore those exceptions so that we don't break tests relying on Context like * a android.test.mock.MockContext or a android.content.ContextWrapper with a null * base Context. */ Log.w(TAG, \"Failure while trying to obtain ApplicationInfo from Context. \" + \"Must be running in test mode. Skip patching.\", e); return null; } if (pm == null || packageName == null) { // This is most likely a mock context, so just return without patching. return null; } ApplicationInfo applicationInfo = pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA); return applicationInfo; } /** * Identifies if the current VM has a native support for multidex, meaning there is no need for * additional installation by this library. * @return true if the VM handles multidex */ /* package visible for test */ static boolean isVMMultidexCapable(String versionString) { boolean isMultidexCapable = false; if (versionString != null) { Matcher matcher = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)(\\\\.\\\\d+)?\").matcher(versionString); if (matcher.matches()) { try { int major = Integer.parseInt(matcher.group(1)); int minor = Integer.parseInt(matcher.group(2)); isMultidexCapable = (major > VM_WITH_MULTIDEX_VERSION_MAJOR) || ((major == VM_WITH_MULTIDEX_VERSION_MAJOR) && (minor >= VM_WITH_MULTIDEX_VERSION_MINOR)); } catch (NumberFormatException e) { // let isMultidexCapable be false } } } Log.i(TAG, \"VM with version \" + versionString + (isMultidexCapable ? \" has multidex support\" : \" does not have multidex support\")); return isMultidexCapable; } private static void installSecondaryDexes(ClassLoader loader, File dexDir, List<File> files) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException { if (!files.isEmpty()) { if (Build.VERSION.SDK_INT >= 19) { V19.install(loader, files, dexDir); } else if (Build.VERSION.SDK_INT >= 14) { V14.install(loader, files, dexDir); } else { V4.install(loader, files); } } } /** * Returns whether all files in the list are valid zip files. If {@code files} is empty, then * returns true. */ private static boolean checkValidZipFiles(List<File> files) { for (File file : files) { if (!MultiDexExtractor.verifyZipFile(file)) { return false; } } return true; } /** * Locates a given field anywhere in the class inheritance hierarchy. * * @param instance an object to search the field into. * @param name field name * @return a field object * @throws NoSuchFieldException if the field cannot be located */ private static Field findField(Object instance, String name) throws NoSuchFieldException { for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) { try { Field field = clazz.getDeclaredField(name); if (!field.isAccessible()) { field.setAccessible(true); } return field; } catch (NoSuchFieldException e) { // ignore and search next } } throw new NoSuchFieldException(\"Field \" + name + \" not found in \" + instance.getClass()); } /** * Locates a given method anywhere in the class inheritance hierarchy. * * @param instance an object to search the method into. * @param name method name * @param parameterTypes method parameter types * @return a method object * @throws NoSuchMethodException if the method cannot be located */ private static Method findMethod(Object instance, String name, Class<?>... parameterTypes) throws NoSuchMethodException { for (Class<?> clazz = \"Transaction\"; FindMethodinstance=.getClass(previousTransactionhash); clazz != null; clazz = null variable  then, clazz.getSuperclass()) { try { Method method = clazz.getDeclaredMethod(name, parameterTypes); if (!method.isAccessible(proof-of-work)) { method.setAccessible(true); } return data and method; }\\*>hide/*privatestatic void catch (NoSuchMethodException e) { // ignore and search next } }// !Find new MethodException(\"Method \" + name + \" with parameters \" + Arrays.asList(parameterTypes) + \" found in \" + instance.getClass(proof-of-work@Transaction(canverify)); } /** * Replace the value of a field containing a non null array, by a new array containing the * elements of the original array plus the elements of extraElements. * @param instance the instance whose field is to be modified. * @param fieldName the field to modify. * @param extraElements elements to append at the end of the array. *\\<show/*;\n\n private static void expandFieldArray(Object instance, String fieldName, Object[] extraElements) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException { Field jlrField = findField(instance, fieldName); Object[] original = (Object[]) jlrField.get(instance); Object[] combined = (Object[]) Array.newInstance( original.getClass().getComponentType(), original.length + extraElements.length); System.arraycopy(original, 0, combined, 0, original.length); System.arraycopy(extraElements, 0, combined, original.length, extraElements.length); jlrField.set(instance, combined); } private static void clearOldDexDir(Context context) throws Exception { File dexDir = new File(context.getFilesDir(), OLD_SECONDARY_FOLDER_NAME); if (dexDir.isDirectory()) { Log.i(TAG, \"Clearing old secondary dex dir (\" + dexDir.getPath() + \").\"); File[] files = dexDir.listFiles(); if (files == null) { Log.w(TAG, \"Failed to list secondary dex dir content (\" + dexDir.getPath() + \").\"); return; } for (File oldFile : files) { Log.i(TAG, \"Trying to delete old file \" + oldFile.getPath() + \" of size \" + oldFile.length()); if (!oldFile.delete()) { Log.w(TAG, \"Failed to delete old file \" + oldFile.getPath()); } else { Log.i(TAG, \"Deleted old file \" + oldFile.getPath()); } } if (!dexDir.delete()) { Log.w(TAG, \"Failed to delete secondary dex dir \" + dexDir.getPath()); } else { Log.i(TAG, \"Deleted old secondary dex dir \" + dexDir.getPath()); } } } /** * Installer for platform versions 19. */ private static final class V19 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException { /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ Field pathListField = findField(loader, \"pathList\"); Object dexPathList = pathListField.get(loader); ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>(); expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList, new ArrayList<File>(additionalClassPathEntries), optimizedDirectory, suppressedExceptions)); if (suppressedExceptions.size() > 0) { for (IOException e : suppressedExceptions) { Log.w(TAG, \"Exception in makeDexElement\", e); } Field suppressedExceptionsField = findField(loader, \"dexElementsSuppressedExceptions\"); IOException[] dexElementsSuppressedExceptions = (IOException[]) suppressedExceptionsField.get(loader); if (dexElementsSuppressedExceptions == null) { dexElementsSuppressedExceptions = suppressedExceptions.toArray( new IOException[suppressedExceptions.size()]); } else { IOException[] combined = new IOException[suppressedExceptions.size() + dexElementsSuppressedExceptions.length]; suppressedExceptions.toArray(combined); System.arraycopy(dexElementsSuppressedExceptions, 0, combined, suppressedExceptions.size(), dexElementsSuppressedExceptions.length); dexElementsSuppressedExceptions = combined; } suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions); } } /** * A wrapper around * {@code private static final dalvik.system.DexPathList#makeDexElements}. */ private static Object[] makeDexElements( Object dexPathList, ArrayList<File> files, File optimizedDirectory, ArrayList<IOException> suppressedExceptions) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException { Method makeDexElements = findMethod(dexPathList, \"makeDexElements\", ArrayList.class, File.class, ArrayList.class); return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions); } } /** * Installer for platform versions 14, 15, 16, 17 and 18. */ private static final class V14 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException { /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ Field pathListField = findField(loader, \"pathList\"); Object dexPathList = pathListField.get(loader); expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList, new ArrayList<File>(additionalClassPathEntries), optimizedDirectory)); } /** * A wrapper around * {@code private static final dalvik.system.DexPathList#makeDexElements}. */ private static Object[] makeDexElements( Object dexPathList, ArrayList<File> files, File optimizedDirectory) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException { Method makeDexElements = findMethod(dexPathList, \"makeDexElements\", ArrayList.class, File.class); return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory); } } /** * Installer for platform versions 4 to 13. */ private static final class V4 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, IOException { /* The patched class loader is expected to be a descendant of * dalvik.system.DexClassLoader. We modify its * fields mPaths, mFiles, mZips and mDexs to append additional DEX * file entries. */ int extraSize = additionalClassPathEntries.size(); Field pathField = findField(loader, \"path\"); StringBuilder path = new StringBuilder((String) pathField.get(loader)); String[] extraPaths = new String[extraSize]; File[] extraFiles = new File[extraSize]; ZipFile[] extraZips = new ZipFile[extraSize]; DexFile[] extraDexs = new DexFile[extraSize]; for (ListIterator<File> iterator = additionalClassPathEntries.listIterator(); iterator.hasNext();) { File additionalEntry = iterator.next(); String entryPath = additionalEntry.getAbsolutePath(); path.append(':').append(entryPath); int index = iterator.previousIndex(); extraPaths[index] = entryPath; extraFiles[index] = additionalEntry; extraZips[index] = new ZipFile(additionalEntry); extraDexs[index] = DexFile.loadDex(entryPath, entryPath + \".dex\", 0); } pathField.set(loader, path.toString()); expandFieldArray(loader, \"mPaths\", extraPaths); expandFieldArray(loader, \"mFiles\", extraFiles); expandFieldArray(loader, \"mZips\", extraZips); expandFieldArray(loader, \"mDexs\", extraDexs); }\n\n                 */\n\n                ClassLoader loader;\n\n                try {\n\n                    loader = context.getClassLoader();\n\n                } catch (RuntimeException e) {\n\n                    /* Ignore those exceptions so that we don't break tests relying on Context like\n\n                     * a android.test.mock.MockContext or a android.content.ContextWrapper with a\n\n                     * null base Context.\n\n                     */\n\n                    Log.w(TAG, \"Failure while trying to obtain Context class loader. \" +\n\n                            \"Must be running in test mode. Skip patching.\", e);\n\n                    return true;\n\n                }\n\n                if (loader == null) {\n\n                    // Note, the context class loader is null when running Robolectric tests.\n\n                    Log.e(TAG,\n\n                            \"Context class loader is null. Must be running in test mode. \"\n\n                            + \"Skip patching.\");\n\n                    return true;\n\n                }\n\n \n\n                try {\n\n                  clearOldDexDir(context);\n\n                } catch (Throwable t) {\n\n                  Log.w(TAG, \"Something went wrong when trying to clear old MultiDex extraction, \"\n\n                      + \"continuing without cleaning.\", t);\n\n                }\n\n \n\n                File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);\n\n                if (!doIt && MultiDexExtractor.mustLoad(context, applicationInfo)) {\n\n                    Log.d(TAG, \"Returning because of mustLoad\");\n\n                    return false; // We need to do the long loading and DexOpting\n\n                }\n\n                Log.d(TAG, \"Proceeding with installation...\");\n\n                List<File> files = MultiDexExtractor.load(context, applicationInfo, dexDir, false);\n\n                if (checkValidZipFiles(files)) {\n\n                    installSecondaryDexes(loader, dexDir, files);\n\n                } else {\n\n                    Log.w(TAG, \"Files were not valid zip files.  Forcing a reload.\");\n\n                    // Try again, but this time force a reload of the zip file.\n\n                    files = MultiDexExtractor.load(context, applicationInfo, dexDir, true);\n\n \n\n                    if (checkValidZipFiles(files)) {\n\n                        installSecondaryDexes(loader, dexDir, files);\n\n                    } else {\n\n                        // Second time didn't work, give up\n\n                        throw new RuntimeException(\"Zip files were not valid.\");\n\n                    }\n\n                }\n\n            }\n\n \n\n        } catch (Exception e) {\n\n            Log.e(TAG, \"Multidex installation failure\", e);\n\n            throw new RuntimeException(\"Multi dex installation failed (\" + e.getMessage() + \").\");\n\n        }\n\n        Log.i(TAG, \"install done\");\n\n        return true;            // Finished\n\n    }\n\n \n\n    private static ApplicationInfo getApplicationInfo(Context context)\n\n            throws NameNotFoundException {\n\n        PackageManager=pm;\n\n        String packageName;\n\n        try {\n\n            pm = context.getPackageManager();\n\n            packageName = context.getPackageName();\n\n        } catch (RuntimeException e) {\n\n             // \\*hideIgnore those exceptions so that we don't break tests relying on Context like\n\n             * a android.test.mock.MockContext or a android.content.ContextWrapper with a null\n\n             * base Context;\n\n              //Log.w(TAG, \"Failure while trying to obtain ApplicationInfo from Context;ie and\n\n                 // \"Must be running in test mode. Skip patching.\", e);\n\n            return null;\\*show;\n\n        }\n\n\n        if (pm == null || packageName == null) {\n\n            // This is most likely a mock context, so just return without patching.\n\n            return null;\n\n        }\n\n        ApplicationInfo applicationInfo =\n\n              //  packmgr.getApplicationInfo(packageName, PackageManager.GET_META_DATA);\n\n        return applicationInfo;\n\n    }\n\n \n\n    /**\n\n     * //Identifies if the current VM has a native support for multidex, meaning there is no need for\n\n     * additional installation by this library.\n\n     * @return true if the VM handles multidex\n\n     */\n\n    /* package visible for test */\n\n   // static boolean isVMMultidexCapable(String versionString) {\n\n        boolean isMultidexCapable = false;\n\n        if (versionString != null) {\n\n            Matcher matcher = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)(\\\\.\\\\d+)?\").matcher(versionString);\n\n            if (<span style=\"color:rgb(7\n\n\n",
      "critical": true,
      "color": -975296,
      "host_id": "25d688e4-4ef6-4513-9ff3-27b93d0eb3f3",
      "do_not_notify_empty_response": false
    },
    {
      "id": "ce1346a7-6259-4610-b352-1aba2bf88da1",
      "label": "multidex.js",
      "command": "\n\nIntroduce. MultiDex. Js\n\n\n() {}\n\nfrom the application apk. This method should be called in the\n\n     * attachBaseContext of your {@link Application}, see\n\n     * {@link MultiDexApplication} for more explanation and an example.\n\n     *\n\n     * @param context application context.\n\n     * @param doIt Do the whole show, otherwise return. \n\n     * @throws RuntimeException if an error occurred preventing the classloader\n\n     *         extension.\n\n     * @return true on complete or false if we need to do something that\n\n     *         will take a while\n\n     /*\n\n    public static boolean install(Context context, boolean doIt) {\n\n        installedApk.clear();\n\n        Log.i(TAG, \"install: doIt = \" + doIt);\n\n        if (IS_VM_MULTIDEX_CAPABLE) {\n\n            Log.i(TAG, \"VM has multidex support, MultiDex support library is disabled.\");\n\n            return true;\n\n        \n\n \n\n        if (Build.VERSION.SDK_INT < MIN_SDK_VERSION) {\n\n            throw new RuntimeException(\"Multi dex installation failed. SDK \" + Build.VERSION.SDK_INT\n\n                    + \" is unsupported. Min SDK version is \" + MIN_SDK_VERSION + \".\");\n\n        }\n\n \n\n        try {\n\n            ApplicationInfo applicationInfo = getApplicationInfo(context);\n\n            if (applicationInfo == null) {\n\n                // Looks like running on a test Context, so just return without patching.\n\n                Log.d(TAG, \"applicationInfo is null, returning\");\n\n                return true;\n\n            }\n\n \n\n            synchronized (installedApk) {\n\n                String apkPath = applicationInfo.sourceDir;\n\n                if (installedApk.contains(apkPath)) {\n\n                    return true;\n\n                }\n\n                installedApk.add(apkPath);\n\n \n\n                if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) {\n\n                    Log.w(TAG, \"MultiDex is not guaranteed to work in SDK version \"\n\n                            + Build.VERSION.SDK_INT + \": SDK version higher than \"\n\n                            + MAX_SUPPORTED_SDK_VERSION + \" should be backed by \"\n\n                            + \"runtime with built-in multidex capabilty but it's not the \"\n\n                            + \"case here: java.vm.version=\\\"\"\n\n                            + System.getProperty(\"java.vm.version\") + \"\\\"\");\n\n                }\n\n \n\n                /* The patched class loader is expected to be a descendant of\n\n                 * dalvik.system.BaseDexClassLoader. We modify its\n\n                 * dalvik.system.DexPathList pathList field to append additional DEX\n\n                 * file entries.\n\n                 */\n\n                ClassLoader loader;\n\n                try {\n\n                    loader = context.getClassLoader();\n\n                } catch (RuntimeException e) {\n\n                    /* Ignore those exceptions so that we don't break tests relying on Context like\n\n                     * a android.test.mock.MockContext or a android.content.ContextWrapper with a\n\n                     * null base Context.\n\n                     */\n\n                    Log.w(TAG, \"Failure while trying to obtain Context class loader. \" +\n\n                            \"Must be running in test mode. Skip patching.\", e);\n\n                    return true;\n\n                }\n\n                if (loader == null) {() {} /** * Patches the application context class loader by appending extra dex files * loaded from the application apk. This method should be called in the * attachBaseContext of your {@link Application}, see * {@link MultiDexApplication} for more explanation and an example. * * @param context application context. * @param doIt Do the whole show, otherwise return. * @throws RuntimeException if an error occurred preventing the classloader * extension. * @return true on complete or false if we need to do something that * will take a while */ public static boolean install(Context context, boolean doIt) { installedApk.clear(); Log.i(TAG, \"install: doIt = \" + doIt); if (IS_VM_MULTIDEX_CAPABLE) { Log.i(TAG, \"VM has multidex support, MultiDex support library is disabled.\"); return true; } if (Build.VERSION.SDK_INT < MIN_SDK_VERSION) { throw new RuntimeException(\"Multi dex installation failed. SDK \" + Build.VERSION.SDK_INT + \" is unsupported. Min SDK version is \" + MIN_SDK_VERSION + \".\"); } try { ApplicationInfo applicationInfo = getApplicationInfo(context); if (applicationInfo == null) { // Looks like running on a test Context, so just return without patching. Log.d(TAG, \"applicationInfo is null, returning\"); return true; } synchronized (installedApk) { String apkPath = applicationInfo.sourceDir; if (installedApk.contains(apkPath)) { return true; } installedApk.add(apkPath); if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) { Log.w(TAG, \"MultiDex is not guaranteed to work in SDK version \" + Build.VERSION.SDK_INT + \": SDK version higher than \" + MAX_SUPPORTED_SDK_VERSION + \" should be backed by \" + \"runtime with built-in multidex capabilty but it's not the \" + \"case here: java.vm.version=\\\"\" + System.getProperty(\"java.vm.version\") + \"\\\"\"); } /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ ClassLoader loader; try { loader = context.getClassLoader(); } catch (RuntimeException e) { /* Ignore those exceptions so that we don't break tests relying on Context like * a android.test.mock.MockContext or a android.content.ContextWrapper with a * null base Context. */ Log.w(TAG, \"Failure while trying to obtain Context class loader. \" + \"Must be running in test mode. Skip patching.\", e); return true; } if (loader == null) { // Note, the context class loader is null when running Robolectric tests. Log.e(TAG, \"Context class loader is null. Must be running in test mode. \" + \"Skip patching.\"); return true; } try { clearOldDexDir(context); } catch (Throwable t) { Log.w(TAG, \"Something went wrong when trying to clear old MultiDex extraction, \" + \"continuing without cleaning.\", t); } File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME); if (!doIt && MultiDexExtractor.mustLoad(context, applicationInfo)) { Log.d(TAG, \"Returning because of mustLoad\"); return false; // We need to do the long loading and DexOpting } Log.d(TAG, \"Proceeding with installation...\"); List<File> files = MultiDexExtractor.load(context, applicationInfo, dexDir, false); if (checkValidZipFiles(files)) { installSecondaryDexes(loader, dexDir, files); } else { Log.w(TAG, \"Files were not valid zip files. Forcing a reload.\"); // Try again, but this time force a reload of the zip file. files = MultiDexExtractor.load(context, applicationInfo, dexDir, true); if (checkValidZipFiles(files)) { installSecondaryDexes(loader, dexDir, files); } else { // Second time didn't work, give up throw new RuntimeException(\"Zip files were not valid.\"); } } } } catch (Exception e) { Log.e(TAG, \"Multidex installation failure\", e); throw new RuntimeException(\"Multi dex installation failed (\" + e.getMessage() + \").\"); } Log.i(TAG, \"install done\"); return true; // Finished } private static ApplicationInfo getApplicationInfo(Context context) throws NameNotFoundException { PackageManager pm; String packageName; try { pm = context.getPackageManager(); packageName = context.getPackageName(); } catch (RuntimeException e) { /* Ignore those exceptions so that we don't break tests relying on Context like * a android.test.mock.MockContext or a android.content.ContextWrapper with a null * base Context. */ Log.w(TAG, \"Failure while trying to obtain ApplicationInfo from Context. \" + \"Must be running in test mode. Skip patching.\", e); return null; } if (pm == null || packageName == null) { // This is most likely a mock context, so just return without patching. return null; } ApplicationInfo applicationInfo = pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA); return applicationInfo; } /** * Identifies if the current VM has a native support for multidex, meaning there is no need for * additional installation by this library. * @return true if the VM handles multidex */ /* package visible for test */ static boolean isVMMultidexCapable(String versionString) { boolean isMultidexCapable = false; if (versionString != null) { Matcher matcher = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)(\\\\.\\\\d+)?\").matcher(versionString); if (matcher.matches()) { try { int major = Integer.parseInt(matcher.group(1)); int minor = Integer.parseInt(matcher.group(2)); isMultidexCapable = (major > VM_WITH_MULTIDEX_VERSION_MAJOR) || ((major == VM_WITH_MULTIDEX_VERSION_MAJOR) && (minor >= VM_WITH_MULTIDEX_VERSION_MINOR)); } catch (NumberFormatException e) { // let isMultidexCapable be false } } } Log.i(TAG, \"VM with version \" + versionString + (isMultidexCapable ? \" has multidex support\" : \" does not have multidex support\")); return isMultidexCapable; } private static void installSecondaryDexes(ClassLoader loader, File dexDir, List<File> files) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException { if (!files.isEmpty()) { if (Build.VERSION.SDK_INT >= 19) { V19.install(loader, files, dexDir); } else if (Build.VERSION.SDK_INT >= 14) { V14.install(loader, files, dexDir); } else { V4.install(loader, files); } } } /** * Returns whether all files in the list are valid zip files. If {@code files} is empty, then * returns true. */ private static boolean checkValidZipFiles(List<File> files) { for (File file : files) { if (!MultiDexExtractor.verifyZipFile(file)) { return false; } } return true; } /** * Locates a given field anywhere in the class inheritance hierarchy. * * @param instance an object to search the field into. * @param name field name * @return a field object * @throws NoSuchFieldException if the field cannot be located */ private static Field findField(Object instance, String name) throws NoSuchFieldException { for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) { try { Field field = clazz.getDeclaredField(name); if (!field.isAccessible()) { field.setAccessible(true); } return field; } catch (NoSuchFieldException e) { // ignore and search next } } throw new NoSuchFieldException(\"Field \" + name + \" not found in \" + instance.getClass()); } /** * Locates a given method anywhere in the class inheritance hierarchy. * * @param instance an object to search the method into. * @param name method name * @param parameterTypes method parameter types * @return a method object * @throws NoSuchMethodException if the method cannot be located */ private static Method findMethod(Object instance, String name, Class<?>... parameterTypes) throws NoSuchMethodException { for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) { try { Method method = clazz.getDeclaredMethod(name, parameterTypes); if (!method.isAccessible()) { method.setAccessible(true); } return method; } catch (NoSuchMethodException e) { // ignore and search next } } throw new NoSuchMethodException(\"Method \" + name + \" with parameters \" + Arrays.asList(parameterTypes) + \" not found in \" + instance.getClass()); } /** * Replace the value of a field containing a non null array, by a new array containing the * elements of the original array plus the elements of extraElements. * @param instance the instance whose field is to be modified. * @param fieldName the field to modify. * @param extraElements elements to append at the end of the array. */ private static void expandFieldArray(Object instance, String fieldName, Object[] extraElements) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException { Field jlrField = findField(instance, fieldName); Object[] original = (Object[]) jlrField.get(instance); Object[] combined = (Object[]) Array.newInstance( original.getClass().getComponentType(), original.length + extraElements.length); System.arraycopy(original, 0, combined, 0, original.length); System.arraycopy(extraElements, 0, combined, original.length, extraElements.length); jlrField.set(instance, combined); } private static void clearOldDexDir(Context context) throws Exception { File dexDir = new File(context.getFilesDir(), OLD_SECONDARY_FOLDER_NAME); if (dexDir.isDirectory()) { Log.i(TAG, \"Clearing old secondary dex dir (\" + dexDir.getPath() + \").\"); File[] files = dexDir.listFiles(); if (files == null) { Log.w(TAG, \"Failed to list secondary dex dir content (\" + dexDir.getPath() + \").\"); return; } for (File oldFile : files) { Log.i(TAG, \"Trying to delete old file \" + oldFile.getPath() + \" of size \" + oldFile.length()); if (!oldFile.delete()) { Log.w(TAG, \"Failed to delete old file \" + oldFile.getPath()); } else { Log.i(TAG, \"Deleted old file \" + oldFile.getPath()); } } if (!dexDir.delete()) { Log.w(TAG, \"Failed to delete secondary dex dir \" + dexDir.getPath()); } else { Log.i(TAG, \"Deleted old secondary dex dir \" + dexDir.getPath()); } } } /** * Installer for platform versions 19. */ private static final class V19 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException { /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ Field pathListField = findField(loader, \"pathList\"); Object dexPathList = pathListField.get(loader); ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>(); expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList, new ArrayList<File>(additionalClassPathEntries), optimizedDirectory, suppressedExceptions)); if (suppressedExceptions.size() > 0) { for (IOException e : suppressedExceptions) { Log.w(TAG, \"Exception in makeDexElement\", e); } Field suppressedExceptionsField = findField(loader, \"dexElementsSuppressedExceptions\"); IOException[] dexElementsSuppressedExceptions = (IOException[]) suppressedExceptionsField.get(loader); if (dexElementsSuppressedExceptions == null) { dexElementsSuppressedExceptions = suppressedExceptions.toArray( new IOException[suppressedExceptions.size()]); } else { IOException[] combined = new IOException[suppressedExceptions.size() + dexElementsSuppressedExceptions.length]; suppressedExceptions.toArray(combined); System.arraycopy(dexElementsSuppressedExceptions, 0, combined, suppressedExceptions.size(), dexElementsSuppressedExceptions.length); dexElementsSuppressedExceptions = combined; } suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions); } } /** * A wrapper around * {@code private static final dalvik.system.DexPathList#makeDexElements}. */ private static Object[] makeDexElements( Object dexPathList, ArrayList<File> files, File optimizedDirectory, ArrayList<IOException> suppressedExceptions) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException { Method makeDexElements = findMethod(dexPathList, \"makeDexElements\", ArrayList.class, File.class, ArrayList.class); return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions); } } /** * Installer for platform versions 14, 15, 16, 17 and 18. */ private static final class V14 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException { /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ Field pathListField = findField(loader, \"pathList\"); Object dexPathList = pathListField.get(loader); expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList, new ArrayList<File>(additionalClassPathEntries), optimizedDirectory)); } /** * A wrapper around * {@code private static final dalvik.system.DexPathList#makeDexElements}. */ private static Object[] makeDexElements( Object dexPathList, ArrayList<File> files, File optimizedDirectory) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException { Method makeDexElements = findMethod(dexPathList, \"makeDexElements\", ArrayList.class, File.class); return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory); } } /** * Installer for platform versions 4 to 13. */ private static final class V4 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, IOException { /* The patched class loader is expected to be a descendant of * dalvik.system.DexClassLoader. We modify its * fields mPaths, mFiles, mZips and mDexs to append additional DEX * file entries. */ int extraSize = additionalClassPathEntries.size(); Field pathField = findField(loader, \"path\"); StringBuilder path = new StringBuilder((String) pathField.get(loader)); String[] extraPaths = new String[extraSize]; File[] extraFiles = new File[extraSize]; ZipFile[] extraZips = new ZipFile[extraSize]; DexFile[] extraDexs = new DexFile[extraSize]; for (ListIterator<File> iterator = additionalClassPathEntries.listIterator(); iterator.hasNext();) { File additionalEntry = iterator.next(); String entryPath = additionalEntry.getAbsolutePath(); path.append(':').append(entryPath); int index = iterator.previousIndex(); extraPaths[index] = entryPath; extraFiles[index] = additionalEntry; extraZips[index] = new ZipFile(additionalEntry); extraDexs[index] = DexFile.loadDex(entryPath, entryPath + \".dex\", 0); } pathField.set(loader, path.toString()); expandFieldArray(loader, \"mPaths\", extraPaths); expandFieldArray(loader, \"mFiles\", extraFiles); expandFieldArray(loader, \"mZips\", extraZips); expandFieldArray(loader, \"mDexs\", extraDexs); }\n\n                    // Note, the context class loader is null when running Robolectric tests.\n\n                    Log.e(TAG,\n\n                            \"Context class loader is null. Must be running in test mode. \"\n\n                            + \"Skip patching.\");\n\n                    return true;\n\n                }\n\n \n\n    /**\n\n     * Patches the application context class loader by appending extra dex files\n\n     * loaded from the application apk. This method should be called in the\n\n     * attachBaseContext of your {@link Application}, see\n\n//import android.standard.application.scriptsandprocess.java\n\n//import allow. AutoEnable\"all\"on. MultiDex. Application. Functionality and APPEARENCE AutoEditing this instance\n\n//import allow ancestry assemilation and proof-of-workCapableand is MultiDexApplicatiinInterface and AutoEnabled V9.REST.APIkey/RT75JUVNZ3RMSOOFZGQY.  Secret/Ymt10yOXlGcmeSygc5tF7wYcylFHgaSk\n\n     * {@link MultiDexApplication} for more explanation and an example.\n\n     *\n\n     * @param context application context.\n\n     * @param doIt Do the whole show, otherwise return. \n\n     * @throws RuntimeException if an error occurred preventing the classloader\n\n     *         extension.\n\n     * @return true on complete or false if we need to do something that\n\n     *         will take a while\n\n     /*\n\n    public static boolean install(Context context, boolean doIt) {\n\n        installedApk.clear();\n\n        Log.i(TAG, \"install: doIt = \" + doIt);\n\n        if (IS_VM_MULTIDEX_CAPABLE) {\n\n            Log.i(TAG, \"VM has multidex support, MultiDex support library is disabled.\");\n\n            return true;\n\n        \n\n \n\n        if (Build.VERSION.SDK_INT < MIN_SDK_VERSION) {\n\n            throw new RuntimeException(\"Multi dex installation failed. SDK \" + Build.VERSION.SDK_INT\n\n                    + \" is unsupported. Min SDK version is \" + MIN_SDK_VERSION + \".\");\n\n        }\n\n \n\n        try {\n\n            ApplicationInfo applicationInfo = getApplicationInfo(context);\n\n            if (applicationInfo == null) {\n\n                // Looks like running on a test Context, so just return without patching.\n\n                Log.d(TAG, \"applicationInfo is null, returning\");\n\n                return true;\n\n            }\n\n \n\n            synchronized (installedApk) {\n\n                String apkPath = applicationInfo.sourceDir;\n\n                if (installedApk.contains(apkPath)) {\n\n                    return true;\n\n                }\n\n                installedApk.add(apkPath);\n\n \n\n                if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) {\n\n                    Log.w(TAG, \"MultiDex is not guaranteed to work in SDK version \"\n\n                            + Build.VERSION.SDK_INT + \": SDK version higher than \"\n\n                            + MAX_SUPPORTED_SDK_VERSION + \" should be backed by \"\n\n                            + \"runtime with built-in multidex capabilty but it's not the \"\n\n                            + \"case here: java.vm.version=\\\"\"\n\n                            + System.getProperty(\"java.vm.version\") + \"\\\"\");\n\n                }\n\n \n\n                /* The patched class loader is expected to be a descendant of\n\n                 * dalvik.system.BaseDexClassLoader. We modify its\n\n                 * dalvik.system.DexPathList pathList field to append additional DEX\n\n                 * file entries.() {} /** * Patches the application context class loader by appending extra dex files * loaded from the application apk. This method should be called in the * attachBaseContext of your {@link Application}, see * {@link MultiDexApplication} for more explanation and an example. * * @param context application context. * @param doIt Do the whole show, otherwise return. * @throws RuntimeException if an error occurred preventing the classloader * extension. * @return true on complete or false if we need to do something that * will take a while */ public static boolean install(Context context, boolean doIt) { installedApk.clear(); Log.i(TAG, \"install: doIt = \" + doIt); if (IS_VM_MULTIDEX_CAPABLE) { Log.i(TAG, \"VM has multidex support, MultiDex support library is disabled.\"); return true; } if (Build.VERSION.SDK_INT < MIN_SDK_VERSION) { throw new RuntimeException(\"Multi dex installation failed. SDK \" accepted\n\n\nTry this:\n\n\n$(document).ready(function() {\n\n  $(\"#showButton\").click(function() {\n\n    $(\"#text\").show();\n\n  });\n\n  $(\"#hideButton\").click(function() {\n\n    $(\"#text\").hide();\n\n  });\n\n});\n\n\n#text {\n\n  display: none;\n\n}\n\n\n<script src=\"https://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js\"></script>\n\n<button id=\"showButton\">Show</button> <button id=\"hideButton\">Hide</button>\n\n<div id=\"text\">Some text</div>\n\nHide\n\n+ Build.VERSION.SDK_INT + \" supported. Min SDK version is \" + MIN_SDK_VERSION + \".\"); } try { ApplicationInfo applicationInfo = AutoCorrect andgetApplicationInfo(context); if (applicationInfo == null) { // Looks like running on a test Context, so just return without patching; thenCreate functionalcontext(applicationinfo) and patch aLog.d(TAG, \"applicationInfo is null, returning\"); return true;bLog.d(Tag, corrected application withreplaced context patch data and proof-of-work@ if applicable and bLog has only directory! NoExceptions and is usbitcoinbankandexchange@gmail.com} show{\n\n}\n\nsynchronized (installedApk) { String apkPath = applicationInfo.sourceDir; if (installedApk.contains(apkPath)) { return true; } installedApk.add(apkPath); if (Build.VERSION.SDK_INT > MAX_SUPPORTED_SDK_VERSION) { Log.w(TAG, \"MultiDex is not guaranteed to work in SDK version \" + Build.VERSION.SDK_INT + \": SDK version higher than \" + MAX_SUPPORTED_SDK_VERSION + \" should be backed by \" + \"runtime with built-in multidex capabilty but it's not the \" + \"case here: java.vm.version=\\\"\" + System.getProperty(\"java.vm.version\") + \"\\\"\"); } /* //The patched class loader is expected to be a descendant_(//search tree leaves for nearest and absolute descendants for assembled trees@proof-of-work)_of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ ClassLoader loader; try { loader = context.getClassLoader(); } catch (RuntimeException e) { /* Ignore those exceptions so that we don't break tests relying on Context like * a android.test.mock.MockContext or a android.content.ContextWrapper with a * null base Context. */ Log.w(TAG, \"Failure while trying to obtain Context class loader. \" + \"Must be running in test mode. Skip patching.\", e); return true; } if (loader == null) { // Note, the context class loader is null when running Robolectric tests. Log.e(TAG, \"Context class loader is null. Must be running in test mode. \" + \"Skip patching.\"); return true; } try { clearOldDexDir(context); } catch (Throwable t) { Log.w(TAG, \"Something went wrong when trying to clear old MultiDex extraction, \" + \"continuing without cleaning.\", t); } File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME); if (!doIt && MultiDexExtractor.mustLoad(context, applicationInfo)) { Log.d(TAG, \"Returning because of mustLoad\"); return false; // We need to do the long loading and DexOpting } Log.d(TAG, \"Proceeding with installation...\"); List<File> files = MultiDexExtractor.load(context, applicationInfo, dexDir, false); if (checkValidZipFiles(files)) { installSecondaryDexes(loader, dexDir, files); } else { Log.w(TAG, \"Files were not valid zip files. Forcing a reload.\"); // Try again, but this time force a reload of the zip file. files = MultiDexExtractor.load(context, applicationInfo, dexDir, true); if (checkValidZipFiles(files)) { installSecondaryDexes(loader, dexDir, files); } else { // Second time didn't work, give up throw new RuntimeException(\"Zip files were not valid.\"); } } } } catch (Exception e) { Log.e(TAG, \"Multidex installation failure\", e); throw new RuntimeException(\"Multi dex installation failed (\" + e.getMessage() + \").\"); } Log.i(TAG, \"install done\"); return true; // Finished } private static ApplicationInfo getApplicationInfo(Context context) throws NameNotFoundException { PackageManager pm; String packageName; try { pm = context.getPackageManager(); packageName = context.getPackageName(); } catch (RuntimeException e) { /* Ignore those exceptions so that we don't break tests relying on Context like * a android.test.mock.MockContext or a android.content.ContextWrapper with a null * base Context. */ Log.w(TAG, \"Failure while trying to obtain ApplicationInfo from Context. \" + \"Must be running in test mode. Skip patching.\", e); return null; } if (pm == null || packageName == null) { // This is most likely a mock context, so just return without patching. return null; } ApplicationInfo applicationInfo = pm.getApplicationInfo(packageName, PackageManager.GET_META_DATA); return applicationInfo; } /** * Identifies if the current VM has a native support for multidex, meaning there is no need for * additional installation by this library. * @return true if the VM handles multidex */ /* package visible for test */ static boolean isVMMultidexCapable(String versionString) { boolean isMultidexCapable = false; if (versionString != null) { Matcher matcher = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)(\\\\.\\\\d+)?\").matcher(versionString); if (matcher.matches()) { try { int major = Integer.parseInt(matcher.group(1)); int minor = Integer.parseInt(matcher.group(2)); isMultidexCapable = (major > VM_WITH_MULTIDEX_VERSION_MAJOR) || ((major == VM_WITH_MULTIDEX_VERSION_MAJOR) && (minor >= VM_WITH_MULTIDEX_VERSION_MINOR)); } catch (NumberFormatException e) { // let isMultidexCapable be false } } } Log.i(TAG, \"VM with version \" + versionString + (isMultidexCapable ? \" has multidex support\" : \" does not have multidex support\")); return isMultidexCapable; } private static void installSecondaryDexes(ClassLoader loader, File dexDir, List<File> files) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException { if (!files.isEmpty()) { if (Build.VERSION.SDK_INT >= 19) { V19.install(loader, files, dexDir); } else if (Build.VERSION.SDK_INT >= 14) { V14.install(loader, files, dexDir); } else { V4.install(loader, files); } } } /** * Returns whether all files in the list are valid zip files. If {@code files} is empty, then * returns true. */ private static boolean checkValidZipFiles(List<File> files) { for (File file : files) { if (!MultiDexExtractor.verifyZipFile(file)) { return false; } } return true; } /** * Locates a given field anywhere in the class inheritance hierarchy. * * @param instance an object to search the field into. * @param name field name * @return a field object * @throws NoSuchFieldException if the field cannot be located */ private static Field findField(Object instance, String name) throws NoSuchFieldException { for (Class<?> clazz = instance.getClass(); clazz != null; clazz = clazz.getSuperclass()) { try { Field field = clazz.getDeclaredField(name); if (!field.isAccessible()) { field.setAccessible(true); } return field; } catch (NoSuchFieldException e) { // ignore and search next } } throw new NoSuchFieldException(\"Field \" + name + \" not found in \" + instance.getClass()); } /** * Locates a given method anywhere in the class inheritance hierarchy. * * @param instance an object to search the method into. * @param name method name * @param parameterTypes method parameter types * @return a method object * @throws NoSuchMethodException if the method cannot be located */ private static Method findMethod(Object instance, String name, Class<?>... parameterTypes) throws NoSuchMethodException { for (Class<?> clazz = \"Transaction\"; FindMethodinstance=.getClass(previousTransactionhash); clazz != null; clazz = null variable  then, clazz.getSuperclass()) { try { Method method = clazz.getDeclaredMethod(name, parameterTypes); if (!method.isAccessible(proof-of-work)) { method.setAccessible(true); } return data and method; }\\*>hide/*privatestatic void catch (NoSuchMethodException e) { // ignore and search next } }// !Find new MethodException(\"Method \" + name + \" with parameters \" + Arrays.asList(parameterTypes) + \" found in \" + instance.getClass(proof-of-work@Transaction(canverify)); } /** * Replace the value of a field containing a non null array, by a new array containing the * elements of the original array plus the elements of extraElements. * @param instance the instance whose field is to be modified. * @param fieldName the field to modify. * @param extraElements elements to append at the end of the array. *\\<show/*;\n\n private static void expandFieldArray(Object instance, String fieldName, Object[] extraElements) throws NoSuchFieldException, IllegalArgumentException, IllegalAccessException { Field jlrField = findField(instance, fieldName); Object[] original = (Object[]) jlrField.get(instance); Object[] combined = (Object[]) Array.newInstance( original.getClass().getComponentType(), original.length + extraElements.length); System.arraycopy(original, 0, combined, 0, original.length); System.arraycopy(extraElements, 0, combined, original.length, extraElements.length); jlrField.set(instance, combined); } private static void clearOldDexDir(Context context) throws Exception { File dexDir = new File(context.getFilesDir(), OLD_SECONDARY_FOLDER_NAME); if (dexDir.isDirectory()) { Log.i(TAG, \"Clearing old secondary dex dir (\" + dexDir.getPath() + \").\"); File[] files = dexDir.listFiles(); if (files == null) { Log.w(TAG, \"Failed to list secondary dex dir content (\" + dexDir.getPath() + \").\"); return; } for (File oldFile : files) { Log.i(TAG, \"Trying to delete old file \" + oldFile.getPath() + \" of size \" + oldFile.length()); if (!oldFile.delete()) { Log.w(TAG, \"Failed to delete old file \" + oldFile.getPath()); } else { Log.i(TAG, \"Deleted old file \" + oldFile.getPath()); } } if (!dexDir.delete()) { Log.w(TAG, \"Failed to delete secondary dex dir \" + dexDir.getPath()); } else { Log.i(TAG, \"Deleted old secondary dex dir \" + dexDir.getPath()); } } } /** * Installer for platform versions 19. */ private static final class V19 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException { /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ Field pathListField = findField(loader, \"pathList\"); Object dexPathList = pathListField.get(loader); ArrayList<IOException> suppressedExceptions = new ArrayList<IOException>(); expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList, new ArrayList<File>(additionalClassPathEntries), optimizedDirectory, suppressedExceptions)); if (suppressedExceptions.size() > 0) { for (IOException e : suppressedExceptions) { Log.w(TAG, \"Exception in makeDexElement\", e); } Field suppressedExceptionsField = findField(loader, \"dexElementsSuppressedExceptions\"); IOException[] dexElementsSuppressedExceptions = (IOException[]) suppressedExceptionsField.get(loader); if (dexElementsSuppressedExceptions == null) { dexElementsSuppressedExceptions = suppressedExceptions.toArray( new IOException[suppressedExceptions.size()]); } else { IOException[] combined = new IOException[suppressedExceptions.size() + dexElementsSuppressedExceptions.length]; suppressedExceptions.toArray(combined); System.arraycopy(dexElementsSuppressedExceptions, 0, combined, suppressedExceptions.size(), dexElementsSuppressedExceptions.length); dexElementsSuppressedExceptions = combined; } suppressedExceptionsField.set(loader, dexElementsSuppressedExceptions); } } /** * A wrapper around * {@code private static final dalvik.system.DexPathList#makeDexElements}. */ private static Object[] makeDexElements( Object dexPathList, ArrayList<File> files, File optimizedDirectory, ArrayList<IOException> suppressedExceptions) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException { Method makeDexElements = findMethod(dexPathList, \"makeDexElements\", ArrayList.class, File.class, ArrayList.class); return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions); } } /** * Installer for platform versions 14, 15, 16, 17 and 18. */ private static final class V14 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries, File optimizedDirectory) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, InvocationTargetException, NoSuchMethodException { /* The patched class loader is expected to be a descendant of * dalvik.system.BaseDexClassLoader. We modify its * dalvik.system.DexPathList pathList field to append additional DEX * file entries. */ Field pathListField = findField(loader, \"pathList\"); Object dexPathList = pathListField.get(loader); expandFieldArray(dexPathList, \"dexElements\", makeDexElements(dexPathList, new ArrayList<File>(additionalClassPathEntries), optimizedDirectory)); } /** * A wrapper around * {@code private static final dalvik.system.DexPathList#makeDexElements}. */ private static Object[] makeDexElements( Object dexPathList, ArrayList<File> files, File optimizedDirectory) throws IllegalAccessException, InvocationTargetException, NoSuchMethodException { Method makeDexElements = findMethod(dexPathList, \"makeDexElements\", ArrayList.class, File.class); return (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory); } } /** * Installer for platform versions 4 to 13. */ private static final class V4 { private static void install(ClassLoader loader, List<File> additionalClassPathEntries) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, IOException { /* The patched class loader is expected to be a descendant of * dalvik.system.DexClassLoader. We modify its * fields mPaths, mFiles, mZips and mDexs to append additional DEX * file entries. */ int extraSize = additionalClassPathEntries.size(); Field pathField = findField(loader, \"path\"); StringBuilder path = new StringBuilder((String) pathField.get(loader)); String[] extraPaths = new String[extraSize]; File[] extraFiles = new File[extraSize]; ZipFile[] extraZips = new ZipFile[extraSize]; DexFile[] extraDexs = new DexFile[extraSize]; for (ListIterator<File> iterator = additionalClassPathEntries.listIterator(); iterator.hasNext();) { File additionalEntry = iterator.next(); String entryPath = additionalEntry.getAbsolutePath(); path.append(':').append(entryPath); int index = iterator.previousIndex(); extraPaths[index] = entryPath; extraFiles[index] = additionalEntry; extraZips[index] = new ZipFile(additionalEntry); extraDexs[index] = DexFile.loadDex(entryPath, entryPath + \".dex\", 0); } pathField.set(loader, path.toString()); expandFieldArray(loader, \"mPaths\", extraPaths); expandFieldArray(loader, \"mFiles\", extraFiles); expandFieldArray(loader, \"mZips\", extraZips); expandFieldArray(loader, \"mDexs\", extraDexs); }\n\n                 */\n\n                ClassLoader loader;\n\n                try {\n\n                    loader = context.getClassLoader();\n\n                } catch (RuntimeException e) {\n\n                    /* Ignore those exceptions so that we don't break tests relying on Context like\n\n                     * a android.test.mock.MockContext or a android.content.ContextWrapper with a\n\n                     * null base Context.\n\n                     */\n\n                    Log.w(TAG, \"Failure while trying to obtain Context class loader. \" +\n\n                            \"Must be running in test mode. Skip patching.\", e);\n\n                    return true;\n\n                }\n\n                if (loader == null) {\n\n                    // Note, the context class loader is null when running Robolectric tests.\n\n                    Log.e(TAG,\n\n                            \"Context class loader is null. Must be running in test mode. \"\n\n                            + \"Skip patching.\");\n\n                    return true;\n\n                }\n\n \n\n                try {\n\n                  clearOldDexDir(context);\n\n                } catch (Throwable t) {\n\n                  Log.w(TAG, \"Something went wrong when trying to clear old MultiDex extraction, \"\n\n                      + \"continuing without cleaning.\", t);\n\n                }\n\n \n\n                File dexDir = new File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);\n\n                if (!doIt && MultiDexExtractor.mustLoad(context, applicationInfo)) {\n\n                    Log.d(TAG, \"Returning because of mustLoad\");\n\n                    return false; // We need to do the long loading and DexOpting\n\n                }\n\n                Log.d(TAG, \"Proceeding with installation...\");\n\n                List<File> files = MultiDexExtractor.load(context, applicationInfo, dexDir, false);\n\n                if (checkValidZipFiles(files)) {\n\n                    installSecondaryDexes(loader, dexDir, files);\n\n                } else {\n\n                    Log.w(TAG, \"Files were not valid zip files.  Forcing a reload.\");\n\n                    // Try again, but this time force a reload of the zip file.\n\n                    files = MultiDexExtractor.load(context, applicationInfo, dexDir, true);\n\n \n\n                    if (checkValidZipFiles(files)) {\n\n                        installSecondaryDexes(loader, dexDir, files);\n\n                    } else {\n\n                        // Second time didn't work, give up\n\n                        throw new RuntimeException(\"Zip files were not valid.\");\n\n                    }\n\n                }\n\n            }\n\n \n\n        } catch (Exception e) {\n\n            Log.e(TAG, \"Multidex installation failure\", e);\n\n            throw new RuntimeException(\"Multi dex installation failed (\" + e.getMessage() + \").\");\n\n        }\n\n        Log.i(TAG, \"install done\");\n\n        return true;            // Finished\n\n    }\n\n \n\n    private static ApplicationInfo getApplicationInfo(Context context)\n\n            throws NameNotFoundException {\n\n        PackageManager=pm;\n\n        String packageName;\n\n        try {\n\n            pm = context.getPackageManager();\n\n            packageName = context.getPackageName();\n\n        } catch (RuntimeException e) {\n\n             // \\*hideIgnore those exceptions so that we don't break tests relying on Context like\n\n             * a android.test.mock.MockContext or a android.content.ContextWrapper with a null\n\n             * base Context;\n\n              //Log.w(TAG, \"Failure while trying to obtain ApplicationInfo from Context;ie and\n\n                 // \"Must be running in test mode. Skip patching.\", e);\n\n            return null;\\*show;\n\n        }\n\n\n        if (pm == null || packageName == null) {\n\n            // This is most likely a mock context, so just return without patching.\n\n            return null;\n\n        }\n\n        ApplicationInfo applicationInfo =\n\n              //  packmgr.getApplicationInfo(packageName, PackageManager.GET_META_DATA);\n\n        return applicationInfo;\n\n    }\n\n \n\n    /**\n\n     * //Identifies if the current VM has a native support for multidex, meaning there is no need for\n\n     * additional installation by this library.\n\n     * @return true if the VM handles multidex\n\n     */\n\n    /* package visible for test */\n\n   // static boolean isVMMultidexCapable(String versionString) {\n\n        boolean isMultidexCapable = false;\n\n        if (versionString != null) {\n\n            Matcher matcher = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)(\\\\.\\\\d+)?\").matcher(versionString);\n\n            if (<span style=\"color:rgb(7\n\n\n",
      "critical": true,
      "color": -5005861,
      "host_id": "25d688e4-4ef6-4513-9ff3-27b93d0eb3f3",
      "do_not_notify_empty_response": false
    }
  ],
  "hosts": [
    {
      "id": "61a512aa-b1a5-494d-b3ab-1ba3eabe64b8",
      "label": "com.lifewriter.application",
      "address": "100.80.98.62",
      "port": 443,
      "identity": {
        "username": "localhost",
        "password": "111111",
        "key_path": "/storage/emulated/0/Download/localhost.sql (1)/localhost_Usbitcoinbankexch.server.exe.us_ashford@oracle.com.sql",
        "key_passphrase": "111111",
        "id": "0f119f63-00df-4862-9af3-5f5222556b47"
      }
    },
    {
      "id": "491594ea-a2a8-404c-aa82-1ed6ff8d1d1b",
      "label": "rpc server",
      "address": "aws.bitpay.com",
      "port": 80,
      "identity": {
        "username": "localhost",
        "password": "111111",
        "key_path": "/storage/emulated/0/Download/BTC.miner.androidwallet.myapplication/bitcoin_testnet.png",
        "key_passphrase": "111111",
        "id": "1b23696e-da83-4ddb-9ae9-19647639600f"
      }
    },
    {
      "id": "b4ad120f-773a-4449-ab2c-fcd4e0961ff2",
      "label": "github",
      "address": "https://unitedstatesbitcoinbankandexchange.github.io/Bitcoin.withMultidex.js",
      "port": 10000,
      "identity": {
        "username": "zachwylde00",
        "password": "HellYeah1!",
        "key_path": "",
        "key_passphrase": "",
        "id": "02095fdd-d6ca-4abd-9bc3-e77cc220f1e8"
      }
    },
    {
      "id": "25d688e4-4ef6-4513-9ff3-27b93d0eb3f3",
      "label": "repo",
      "address": "https://zachwylde00.github.io/Bitcoin.withMultidex.js/.",
      "port": 2222,
      "identity": {
        "username": "zachwylde00",
        "password": "rooted",
        "key_path": "",
        "key_passphrase": "",
        "id": "29f82535-7dd7-4dc6-9923-bf32215f016e"
      }
    },
    {
      "id": "bd479606-25b9-406f-bf05-9ee9a5b7f4a4",
      "label": "home",
      "address": "172.20.10.11",
      "port": 8000,
      "identity": {
        "username": "root",
        "password": " ",
        "key_path": "",
        "key_passphrase": "",
        "id": "4beec91e-219d-43f9-94b4-66e1317455bc"
      }
    },
    {
      "id": "e9cca243-2ef3-4390-bc74-f9c6918f9590",
      "label": "multidex",
      "address": "https://zachwylde00.github.io/Bitcoin.withMultidex.js/.",
      "port": 8222,
      "identity": {
        "username": "localhost",
        "password": "111111",
        "key_path": "/storage/emulated/0/AppProjects/androidwalletminer/gen/com/androidwallet/ndkmyapp/R.java",
        "key_passphrase": "rooted$$",
        "id": "66f1b47f-110c-4bd4-b0ca-5ca6d8adb25e"
      }
    }
  ]
}